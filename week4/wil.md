Database Internals에서 B Tree에 대한 내용을 읽어보면서, 확실하게 이해가 안가는 부분이 너무 많았다. 그래서 B tree에 대한 기본적인 학습이 필요하다고 생각해서 검색을 하던 중, 예제를 통해서 B tree에 대해 학습할 수 있는 영상을 찾았다. 그래서 그 내용을 정리해봤다.
> 책에서 B-Tree Node Splits 와 B-Tree Node Merges에 해당하는 내용이 정확하게 이 내용이다. 분할과 병합이 데이터 삽입 과정에서 이루어지는 분할과, 데이터 삭제 과정에서 이루어지는 병합을 일반화시켜서 설명한 내용이다.

**B Tree란? BST의 일반화한 형태라고 생각하면 된다.**

- 최대 몇 개의 자녀 노드를 가질 것인지가 B Tree를 사용할 때 중요한 파라미터이다.

 **M** : 각 노드의 최대 자녀 노드 수
- 최대 M개의 자녀를 가질 수 있는 B tree를 M차 B tree라고 부른다.

**M - 1** : 각 노드의 최대 key 수

**M / 2 의 올림** : 각 노드의 최소 자녀 노드 수(root, leaf node는 제외)
	(M / 2 = 1.5 라면, 2)
**M / 2 의 올림 - 1** : 각 노드의 최소 key 수(root node는 제외)

- internal 노드의 key 수가 x개라면, 자녀 노드의 수는 언제나 x + 1개다.
- 노드 내의 key들은 오름차순으로 정렬되어 젖아된다.
- 모든 leaf노드들은 같은 레벨에 있다.

## B Tree의 데이터 삽입
- 데이터의 추가는 항상 leaf노드에 한다.
- 노드가 넘치면(최대 key의 수보다 커진다면) 가운데(median) key를 기준으로 좌우 key들은 분할하고 가운데 key는 승진한다.

3차 B tree를 예시로 해보자.

![image](https://github.com/user-attachments/assets/b4ccebb2-10d3-4d38-902e-a8b46ea6cca5)
   (https://www.youtube.com/watch?v=bqkcoSm_rCs&t=1045s)
   위 영상에 B tree에 데이터가 어떻게 삽입되는지 과정이 자세하게 설명되어있다. 책을 읽어보면서 B Tree가 어떻게 작동하는건지 머릿속으로 그려지지가 않아서 애매모호한 느낌이었는데, 위 영상을 보고 데이터 삽입이 어떻게 진행되는지 확실하게 이해했다.
   + balanced tree이므로, 검색을 할 때 평균/최악의 경우에 차이가 거의 없다. (O(log N)으로  시간복잡도 동일)

## B tree 데이터 삭제
- 삭제도 항상 leaf노드에서 발생한다.
- 삭제 후 최소 key수보다 적어지면 재조정해준다.
	1.  key 수가 여유있는 형제의 지원을 받는다.
	2.  1이 불가능하면 부모의 지원을 받고, 형제와 합친다.
	3.  2번 후 부모에 문제가 있다면, 거기서 다시 재조정한다.
(https://www.youtube.com/watch?v=H_u28u0usjA&t=1266s)
1. key수가 여유있는 형제의 지원을 받는다.
	- B tree는 자식-부모-자식-부모-자식 순서로 정렬되어있으므로 재조정이 필요한 leaf노드는 정렬된 순서에 맞게 부모 노드로부터 지원을 받고, 여유있는 형제가(좌측(값이 작은 노드) 우선) 다시 부모 노드한테 지원을 해 준다.
2. 형제 모두 여유가 없을 때, 부모의 지원을 받고 형제와 합친다.
	- 동생 > 형 우선순위로 문제가 생긴 노드와 형제노드 사이의 key를 부모로부터 지원받고, 좌측으로 합친 후, 원래 문제가 생겼던 나의 노드를 삭제한다.
	- 합칠때는 항상 좌측으로 합친다.
3. 부모가 자식한테 지원한 후 부모 노드에 문제가 생기면, 상황에 맞게 대응해준다.
	1.  부모가 root노드가 아니라면, 그 위치부터 다시 1번부터 재조정 과정을 진행한다.
	2.  부모가 root노드이고 비어있다면, 부모 노드를 삭제한 후, 합친 노드가 새로운 root노드가 된다.

### internal 노드의 데이터 삭제
- internal 노드에 있는 데이터를 삭제하려면 **leaf 노드에 있는 데이터와 위치를 바꾼 후** 삭제한다.
	- leaf 노드에 있는 데이터들 중에 어떤 데이터와 위치를 바꿀것인지가 이슈!
	- 삭제할 데이터의 선임자(predecessor, 나보다 작은 데이터들 중 가장 큰 데이터)나 후임자(successor, 나보다 큰 데이터들 중 가장 작은 데이터)와 위치를 바꿔주면 된다. (선임자나 후임자는 항상 leaf노드에 있음)
	- 그러면 B Tree의 속성을 그대로 만족시켜준다.

 
+  Chapter 3. File Formats 공부하기 +
# 3장 파일 형식
- 주 메모리에 접근하는 방식과 디스크에 접근하는 방식은 다르다.
- 메모리 접근은 오프셋(데이터 패킷에서 실제 데이터(페이로드)가 시작되는 위치)을 수동으로 관리할 필요가 없지만, 디스크는 시스템 호출을 사용하여 접근한다.
	- 디스크는 일반적으로 대상 파일 내의 오프셋을 지정한 다음, 디스크 상의 표현을 주 메모리에 적합한 형태로 해석해야 한다.

## 동기 (Motivation)
파일 형식을 만드는 것은 관리되지 않는 메모리 모델을 가진 언어(C, C++같은 언어)에서 데이터 구조(구조체?)를 만드는 방식과 유사하다.
- 데이터 블록을 할당하고 고정 크기 기본 요소와 구조를 사용하여 원하는 방식으로 분할한다.
- 디스크에서는 GC와 조각화를 직접 처리해야 한다.
- 주 메모리에 데이터를 저장할 때, 메모리 레이아웃과 관련된 대부분의 문제는 존재하지 않거나, 해결하기 쉽거나, 타사 라이브러리를 사용하여 해결할 수 있다.

## 이진 인코딩 (Binary Encoding)
: 디스크에 데이터를 효율적으로 저장하려면 간결하고 직렬화, 역직렬화하기 쉬운 형식을 사용하여 인코딩해야한다. 

### 기본 타입 (Primary Type)
: 키와 값은 정수, 날짜 또는 문자열과 같은 타입을 가지며, 원시 이진 형태로 표현(직렬화 및 역직렬화)될 수 있다.

엔디언
- 빅 엔디언 : 순서가 MSB부터 시작해서 중요도가 감소하는 순서로 바이트가 이어진다. -> MSB가 가장 낮은 주소를 갖는다
- 리틀 엔디언 : LSB부터 시작해서 중요도가 증가하는 순서로 바이트가 이어진다.
![image](https://github.com/user-attachments/assets/7c522d26-9e51-4fe6-87d0-96dbb8634841)

- 레코드는 숫자, 문자열, boolean 과 같은 기본 요소와 그 조합으로 구성된다.
	- 그러나 네트워크를 통해 데이터를 전송하거나 디스크에 저장할 때는 바이트 시퀀스만 사용할 수 있다.
	- 즉, 레코드를 보내거나 쓰려면 직렬화(해석 가능한 바이트 시퀀스로 변환)해야하고, 받거나 읽은 후 사용하려면 역직렬화 해야한다.

부동 소수점 숫자(float, double)는 부호, 가수 및 지수로 표현된다. float는 32 bit 단정밀도 값을 나타내고, double은 64bit 배정밀도 값을 나타낸다.
> 지금 배우고 있는 수치해석에서 배웠던 내용. IEEE 754에 대한 내용이다.

### 문자열 및 가변 크기 데이터(Strings and Variable-Size Data)
: 문자열및 기타 가변 크기 데이터 타입은 배열 또는 문자열의 길이를 나타내는 숫자와 그 뒤에 오는 size바이트로 직렬화될 수 있다.
- UCSD문자열 : 문자열 끝에 \0 을 이용한 null종료 문자열 형태로 저장된다.
	- H  e  l  l  o  \0
	-  문자열을 가변적으로 조작하기 쉽다.
	-  많은 프로그래밍 언어에서 널리 사용된다.
	-  문자열 길이를 계산하려면 \0 을 찾아야하므로 처리 시간이 필요하다.
- 파스칼 문자열 : 문자열 앞에 길이를 명시한 길이 기반 문자열 형태로 저장된다.
	- 5  H  e  l  l  o
	- 문자열 길이가 명확하게 저장되므로 길이 계산이 빠르다.
	- 검색 및 조작 속도가 빠를 수 있다.
	- 문자열 변경이 어렵거나 추가적인 메모리 조작이 필요할 수 있다.

### 비트 패킹 데이터 : Booleans, Enums, and Flags
- Boolean : 단일 바이트를 사용하거나 true와 false를 각각 1과 0으로 인코딩하여 표현한다.
- Enum : 열거형, 자주 반복되는 낮은 카디널리티 값을 나타내는 데 사용된다. 
- Flag : Boolean과 Enum의 조합이다. 플래그는 상호 배타적이지 않은 명명된 불리언 매개변수를 나타낼 수 있다.
	- 예를 들어, 페이지가 값 셀을 보유하는지 여부
	- 값이 고정 크기인지 가변 크기인지 여부
	- 이 노드와 관련된 오버플로 페이지가 있는지 여부를 나타내는 등
- 모든 비트가 플래그 값을 나타내므로 2의 거듭제곱 값만 사용할 수 있다.
```c
int IS_LEAF_MASK = 0x01h; // bit #1 
int VARIABLE_SIZE_VALUES = 0x02h; // bit #2 
int HAS_OVERFLOW_PAGES = 0x04h; // bit #3
```

비트 OR ( | )연산을 통해 여러 개의 플래그를 추가할 수 있다.
```c
int permission = 0; // 초기값 (권한 없음)
permission = permission | 1; // 읽기(Read) 추가
permission = permission | 2; // 쓰기(Write) 추가
```
위 코드 실행 후 permission 값은 3(0011)이 되어 읽기 + 쓰기 권한을 동시에 가지게된다.

```c
int read = 1 << 0;  // 0001 (1)
int write = 1 << 1; // 0010 (2)
int execute = 1 << 2; // 0100 (4)
```
위와 같이 비트 쉬프트( << )를 통해 플래그를 쉽게 설정할 수 있다.
