Database Internals에서 B Tree에 대한 내용을 읽어보면서, 확실하게 이해가 안가는 부분이 너무 많았다. 그래서 B tree에 대한 기본적인 학습이 필요하다고 생각해서 검색을 하던 중, 예제를 통해서 B tree에 대해 학습할 수 있는 영상을 찾았다. 그래서 그 내용을 정리해봤다.

> B Tree란? BST의 일반화한 형태라고 생각하면 된다.

- 최대 몇 개의 자녀 노드를 가질 것인지가 B Tree를 사용할 때 중요한 파라미터이다.

 **M** : 각 노드의 최대 자녀 노드 수
- 최대 M개의 자녀를 가질 수 있는 B tree를 M차 B tree라고 부른다.
**M - 1** : 각 노드의 최대 key 수

**M / 2 의 올림** : 각 노드의 최소 자녀 노드 수(root, leaf node는 제외)
	(M / 2 = 1.5 라면, 2)
**M / 2 의 올림 - 1** : 각 노드의 최소 key 수(root node는 제외)

- internal 노드의 key 수가 x개라면, 자녀 노드의 수는 언제나 x + 1개다.
- 노드 내의 key들은 오름차순으로 정렬되어 젖아된다.
- 모든 leaf노드들은 같은 레벨에 있다.

## B Tree의 데이터 삽입
- 데이터의 추가는 항상 leaf노드에 한다.
- 노드가 넘치면(최대 key의 수보다 커진다면) 가운데(median) key를 기준으로 좌우 key들은 분할하고 가운데 key는 승진한다.

3차 B tree를 예시로 해보자.

![image](https://github.com/user-attachments/assets/b4ccebb2-10d3-4d38-902e-a8b46ea6cca5)
   (https://www.youtube.com/watch?v=bqkcoSm_rCs&t=1045s)
   위 영상에 B tree에 데이터가 어떻게 삽입되는지 과정이 자세하게 설명되어있다. 책을 읽어보면서 B Tree가 어떻게 작동하는건지 머릿속으로 그려지지가 않아서 애매모호한 느낌이었는데, 위 영상을 보고 데이터 삽입이 어떻게 진행되는지 확실하게 이해했다.
   + balanced tree이므로, 검색을 할 때 평균/최악의 경우에 차이가 거의 없다. (O(log N)으로  시간복잡도 동일)

## B tree 데이터 삭제
- 삭제도 항상 leaf노드에서 발생한다.
- 삭제 후 최소 key수보다 적어지면 재조정해준다.
	1.  key 수가 여유있는 형제의 지원을 받는다.
	2.  1이 불가능하면 부모의 지원을 받고, 형제와 합친다.
	3.  2번 후 부모에 문제가 있다면, 거기서 다시 재조정한다.
(https://www.youtube.com/watch?v=H_u28u0usjA&t=1266s)
1. key수가 여유있는 형제의 지원을 받는다.
	- B tree는 자식-부모-자식-부모-자식 순서로 정렬되어있으므로 재조정이 필요한 leaf노드는 정렬된 순서에 맞게 부모 노드로부터 지원을 받고, 여유있는 형제가(좌측(값이 작은 노드) 우선) 다시 부모 노드한테 지원을 해 준다.
2. 형제 모두 여유가 없을 때, 부모의 지원을 받고 형제와 합친다.
	- 동생 > 형 우선순위로 문제가 생긴 노드와 형제노드 사이의 key를 부모로부터 지원받고, 좌측으로 합친 후, 원래 문제가 생겼던 나의 노드를 삭제한다.
	- 합칠때는 항상 좌측으로 합친다.
3. 부모가 자식한테 지원한 후 부모 노드에 문제가 생기면, 상황에 맞게 대응해준다.
	1.  부모가 root노드가 아니라면, 그 위치부터 다시 1번부터 재조정 과정을 진행한다.
	2.  부모가 root노드이고 비어있다면, 부모 노드를 삭제한 후, 합친 노드가 새로운 root노드가 된다.

### internal 노드의 데이터 삭제
- internal 노드에 있는 데이터를 삭제하려면 **leaf 노드에 있는 데이터와 위치를 바꾼 후** 삭제한다.
	- leaf 노드에 있는 데이터들 중에 어떤 데이터와 위치를 바꿀것인지가 이슈!
	- 삭제할 데이터의 선임자(predecessor, 나보다 작은 데이터들 중 가장 큰 데이터)나 후임자(successor, 나보다 큰 데이터들 중 가장 작은 데이터)와 위치를 바꿔주면 된다. (선임자나 후임자는 항상 leaf노드에 있음)
	- 그러면 B Tree의 속성을 그대로 만족시켜준다.

 
+  Chapter 3. File Formats 공부하기 +
