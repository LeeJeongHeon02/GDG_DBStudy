# Bw-Tree (버즈워드 트리)

: 기존 B-Tree가 가지고 있던 여러 문제점들을 해결하기 위해 나온 트리이다.

## 기존 B-Tree의 문제점

1. Write Amplification(쓰기 증폭) : B-Tree는 데이터를 업데이트할 때마다 해당 페이지를 디스크에 다시 써야 하는 경우가 많다. 이는 디스크 I/O를 많이 발생시켜 성능 저하의 원인이 된다.
2. Space Amplification(공간 증폭) :  B-Tree는 업데이트가 용이하도록 미리 여유 공간을 확보해 둔다. 이 때문에 실제로 필요한 데이터보다 더 많은 공간을 디스크에 할당하게 되고, 데이터를 읽어올 때 유용한 데이터 외에 빈 공간이나 페이지의 나머지 부분까지 함께 전송해야 하는 비효율이 발생한다.
3. complexity in solving concurrency problems and dealing with latches(동시성 문제와 래치 처리의 복잡성) : 여러 사용자가 동시에 B-Tree를 수정하려고 할 때, 데이터의 일관성을 유지하기 위해 래치(Lock과 유사한 짧은 기간의 잠금)를 사용해야 한다. 이 래치 메커니즘을 구현하고 관리하는 것이 매우 복잡하다고 한다.

## Bw-Tree는 이 문제를 어떻게 해결했나?

1. **Append-Only 방식 저장:** 데이터를 수정할 때 기존 데이터를 덮어쓰지 않고, 항상 새로운 변경 사항을 추가하는 방식으로 저장한다.
2. **노드 연결 (Update Chains):** 변경 사항들을 서로 연결하여 마치 체인(사슬)처럼 만듭니다. 다음 챕터에서 자세하게 볼 예정.
3. **Lock-Free 트리:** 메모리 내에서 노드 간의 포인터를 단일 compare-and-swap (CAS) 연산으로 설치할 수 있는 데이터 구조를 사용하여, 복잡한 래치 없이도 트리가 동시성 문제를 해결할 수 있도록 한다.

## Update Chains

: Bw-Tree의 핵심적인 특징 중 하나이다.

- Bw-Tree는 원래의 데이터(기본 노드)와 데이터의 수정 사항(델타 노드)을 분리해서 저장한다.
- 수정 사항(델타 노드)는 서로 연결된 리스트 형태의 체인을 이룬다. 이 체인은 가장 최근의 수정 사항부터 시작해서, 그 전의 수정 사항들을 거쳐서 최종적으로 맨 끝에 있는 기본 노드에 도달하는 방식으로 연결되어있다.
- **쓰기 효율성(쓰기 증폭 문제 해결) :** 각 업데이트는 기존 디스크에 있는 노드를 다시 쓸 필요 없이, 별도의 델타 노드로 저장된다. 이는 쓰기 증폭 문제를 크게 줄여준다.(그러면 저장 공간을 많이 잡아먹지않나…?).
- **공간 효율성(공간 증폭 문제 해결) :** 기본 노드나 델타 노드의 크기는 고정되어 있지 않으며, 페이지 크기에 맞춰 정렬될 필요도 없다. 그리고 노드들이 업데이트될 때 기존 노드가 변경되는 것이 아니라 새로운 델타 노드가 추가될 뿐이므로, 추가적인 공간을 미리 예약할 필요가 없다.

## Taming Concurrency with Compare-and-Swap(CaS를 이용한 동시성 제어)

- Bw-Tree는 델타 체인과 기본 노드로 구성된 Bw-Tree 노드들이 '논리적 식별자'를 가지고, 이 식별자를 디스크 상의 실제 위치와 매핑하는 '인메모리 매핑 테이블(in-memory mapping table)'을 사용한다.
- 이 매핑 테이블을 사용함으로써 Bw-Tree는 '래치(= 짧은 기간의 잠금이라고 이해)'를 없앨 수 있다.

<img width="613" height="195" alt="image" src="https://github.com/user-attachments/assets/80e8f0d6-8bda-42d9-a8b9-c1769bbd2d55" />


### **Bw-Tree 노드 업데이트 과정**을 살펴보자.

1. 대상 노드 찾기 : 루트 노드에서 리프 노드까지 트리를 탐색하여 업데이트하려는 논리적 리프 노드를 찾는다. 매핑 테이블은 대상 기본 노드 또는 업데이트 체인에서 가장 최신 델타 노드에 대한 가랑 링크를 포함한다.
2. **새 델타 노드 생성** : 1단계에서 찾은 기본 노드(또는 최신 델타 노드)를 가리키는 새로운 델타 노드를 생성한다.
3. **매핑 테이블 업데이트** : 2단계에서 생성된 새 델타 노드를 가리키도록 매핑 테이블을 업데이트한다.(이 업데이트가 CAS연산으로 이루어짐)

## Structural Modification Operations (SMO)

: 대표적인 SMO(구조적 수정)은 분할과 병합이 있다. B-Tree의 분할과 병합과 개념적으로는 비슷하지만, 구현 방식이 다르다.

### 분할 (Split SMO) 과정

1. **노드 내용 통합 :** 분할하려는 노드의 논리적 내용(기본 노드에 모든 델타를 적용하여 최종 상태를 만듦)을 먼저 통합한다. 그리고 분할 지점의 오른쪽에 새 페이지를 생성한다.
2. **분할 델타 노드 추가 :** 분할이 진행 중임을 읽는 스레드에게 알리기 위해 '특별한 분할 델타 노드(split delta node)'가 분할하려는 노드에 추가된다.
3. **부모 업데이트** : 새 노드는 분할 델타 노드를 통해 접근 가능하지만, 아직 부모 노드에서 참조되지 않는다. 따라서 읽는 스레드는 이전 노드를 거쳐 형제 포인터를 따라 새로 생성된 형제 노드에 도달해야 한다. 이때 부모 노드의 자식으로 새로운 노드를 추가하여 읽는 스레드가 분할 노드를 거치지 않고 직접 새 노드에 도달할 수 있게 한다. 

### 병합(merge SMO) 과정

1. **형제 노드 제거 델타 추가 :** 병합 SMO의 시작을 알리고 오른쪽 형제 노드를 삭제 대상으로 표시하기 위해 '특별한 제거 델타 노드(remove delta node)'를 오른쪽 형제 노드에 추가한다.
2. **병합 델타 노드 생성:** 왼쪽 형제 노드에 '병합 델타 노드(merge delta node)'를 생성하여 오른쪽 형제 노드의 내용을 가리키고, 이를 왼쪽 형제 노드의 논리적 일부로 만든다.
3. **부모 업데이트:** 이 시점에서 오른쪽 형제 노드의 내용은 왼쪽 노드를 통해 접근 가능합니다. 병합 프로세스를 완료하기 위해 부모 노드에서 오른쪽 형제 노드에 대한 링크를 제거해야 한다.

## Consolidation and Garbage Collection (통합 및 가비지 컬렉션)

: Bw-Tree의 델타 체인은 아무런 조치 없이 계속 길어질 수 있다. 하지만 델타 체인이 길어질수록 데이터를 읽을 때 더 많은 델타 노드를 따라가야 하므로 읽기 비용이 증가하게 된다. 이를 해결하기 위해 Bw-Tree는 '통합(Consolidation)'과 '가비지 컬렉션(Garbage Collection)' 메커니즘을 사용한다.

- **델타 체인 길이 관리** : 델타 체인의 길이가 미리 설정한 임계값에 도달하면, 해당 노드를 **재구축**(기본 노드의 내용과 모든 델타 노드를 병합하여 하나의 새로운 기본 노드를 만드는 과정)한다.
- **새로운 노드 저장 및 포인터 업데이트** : 통합된 노드는 디스크의 새로운 위치에 쓰여지고, 매핑 테이블의 노트 포인터가 이 새 노드를 가리키도록 업데이트된다.
- **GC의 필요성** : 노드가 통합되면, 이전 내용은 더 이상 매핑 테이블에서 참조되지 않는다. 하지만, 이들이 차지하고 있던 메모리를 즉시 해제하는것은 위험하다. 왜냐면 진행 중인 일부 작업이 이 오래된 노드를 사용하고 있을 수 있기 때문이다.
- **래치 없는 환경에서의 메모리 해제** : Bw_Tree는 읽기 스레드가 어떤 래치도 사용하지 않으므로, 활성 페이지를 추적할 다른 방법이 필요하다.
- **에포크(Epoch) 기반 회수** :  Bw-Tree는 특정 노드가 어떤 스레드에 의해 이미 접근되었을 수 있는지 또는 절대 접근될 수 없었는지 구분하기 위해서 이 기술을 사용한다.

## Bw-Tree의 장점 요약!

- **쓰기 증폭 (Write Amplification) 감소:** 델타 노드와 통합 방식을 통해 디스크 쓰기 횟수를 줄인다
- **비차단 접근 (Nonblocking Access):** CAS 연산을 통해 읽기 및 쓰기 작업이 서로를 차단하지 않아 동시성을 크게 향상시킨다.

## Cache-Oblivious B-Trees (캐시 불인지 B-Tree)
