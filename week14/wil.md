# 읽기, 쓰기, 공간 증폭 : LSM Tree의 3가지 비용

: Immutable 데이터 구조를 사용할 때, 세가지 증폭 문제에 직면하게 된다.

> 증폭 (Amplification)이란?
논리적으로 한 번의 작업(읽기, 쓰기, 삭제)을 요청했지만, 시스템 내부적으로 위 작업을 여러번 수행하는 현상을 뜻한다.
> 

## 쓰기 증폭

: 한 번의 쓰기를 요청했을때, 내부적으로 데이터가 디스크에 여러 번 쓰여지는 현상

### LSM Tree에서의 예시

1. 첫 번째 쓰기는 메모리의 Memtable에 기록되고, WAL에도 기록된다. (쓰기 1회)
2. Memtable이 가득차면, 그 내용은 SSTable형태로, Level 0 디스크에 플러쉬된다. (쓰기 2회)
3. Level 0에 파일이 너무 많아지면, 다음 레벨의 파일들과 merge되어 새로운 Level 1파일을 만드는 Compaction 과정을 거친다. 이떄, Level0에 있던 데이터는 또 다시 디스크에 쓰여진다. (쓰기 3회)
4. 데이터는 다음 레벨의 파일들과 merge될떄마다 반복해서 쓰여진다.
: 결과적으로 우리가 한번 삽입한 데이터가, 내부적으로 디스크에 반복적으로 쓰여지게 된다. 이게 **쓰기 증폭** 이다.

> B-Tree에서의 쓰기증폭과 LSM Tree에서의 쓰기증폭의 차이?
B-Tree에서는 엄청 작은 데이터를 수정하기 위해서 페이지 전체(4~16KB) 크기의 페이지 전체를 다시 읽고 써야하는데에서 발생
LSM Tree에서는 위 과정처럼 하나의 데이터가 여러 번 쓰여지는데에서 발생
> 

## 읽기 증폭

: 쓰기 증폭과 비슷하게, 데이터 내부적으로 여러 번 파일과 메모리 구조를 확인해야 하는 현상

### LSM Tree에서의 예시

1. Memtable을 먼저 확인한다.
2. Compaction 되기 전의 Level 0의 모든 SSTable을 확인한다.
3. 그래도 없으면, Lv1, Lv2순서로 키가 존재할 수 있는 SSTable을 하나씩 찾아내려간다.
: 결과적으로, 운이 나쁘면 메모리에서부터 디크스에 있는 수많은 파일들을 열어봐야 할 수도 있다. 이게 **읽기 증폭** 이다.

## 공간 증폭

: 실제 데이터의 크기보다 훨씬 더 많은 물리적 디스크 공간을 차지하는 현상

### LSM Tree에서의 예시

- **중복 데이터** : 데이터가 업데이트되면 이전 버전의 데이터는 즉시 삭제되지 않고 SSTable에 남아있다. 이 데이터는 나중에 Compaction이 될 떄까지 디스크 공간을 계속 차지한다.
- **Tombstones** : 실제 데이터와 툼스톤이 컴팩션으로 병합되기 전까지는 둘 다 디스크에 존재한다.
- **Compaction 중 공간 사용** : 컴팩션을 진행하려면 기존 SSTable(이하 걍 SST라함)들을 읽어서 새로운 SST를 만들어야 한다. 즉 이 과정이 완료되기 전까지는 거의 두 배에 가까운 공간이 필요할 수 있다.

## RUM Conjecture(럼 추측)

: **R**ead - 읽기 증폭, **U**pdate - 쓰기 증폭, **M**emory - 공간 증폭
이 세 가지를 동시에 모두 최적화할 수는 없다!!

- 즉 이 세가지 요소는 서로 트레이드오프 관계에 있다.

**B-Tree는?**

- 데이터를 찾기 위해 단 한번의 탐색 -> R(읽기비용) 낮음
- in-place-update를 위해 페이지 내에 여유 공간을 두어야하고, 작은 변경에도 페이지 전체를 다시 써야하므로 U(쓰기비용), M(공간 비용)이 높다.
**LSM Tree는?**
- 메모리에 데이터를 그냥 추가하면 되므로 U낮음
- 하지만, 데이터를 찾기 위해 여러 파일을 뒤져야하므로 R높고, 중복 데이터로 인해 M도 발생한다.

# SSTable

: Sorted String Table의 약자이다.

- 내부의 모든 데이터 레코드는 key를 기준으로 정렬되어있다.
- 실제로는 임의의 바이트 시퀀스의 형태로 데이터가 저장된다. 즉, 어떤 형태의 데이터든 저장할 수 ㅣㅆ다.
- 가장 중요한 특징은 불변 파일이라는 점이다.

## SSTable의 내부 구조: 데이터 파일과 인덱스 파일

- 데이터 파일은 실제 Key-value쌍들이 들어있는 파일이다.
- 인덱스 파일은 책의 목차처럼, 특정 키를 빠르게 찾을 수 있도록 도와주는 보조 파일이다.

## SSTable은 어떻게 만들어지고 사용될까?

1. **생성**
- memtable이 가득 차서 디스크로 플러시될때나, 여러 개의 SSTable이 컴팩션될떄 생성된다.
- 이미 정렬된 상태의 memtable데이터를 순차적으로 한번에 쭉 쓰기만 하면 된다.
- 데이터를 쓰는 동시에 각 데이터 레코드의 디스크상 위치가 정해지므로 인덱스 파일도 함꼐 생성할 수 있다.
1. 컴팩션에서의 역할
- 정렬된 파일을 병합하는 과정은 Merge-sort 알고리즘과 동일하다.
- 순차적으로 데이터를 읽어오면서 병합하고, 각 결과를 새로은 SSTable에 순차적으로 쓰면 된다.
