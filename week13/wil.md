# Chapter7 - Log-Structured Storage
: 챕터 7에서는 데이터 저장 방식을 가변방식과 불변방식으로 나누어 설명한다. 특히, LSM의 개념과 장점 그리고 LSM-tree에 대해서 알려준다.

## Immutable 저장 구조의 장점
- 기존 파일을 수정하지 않고, 새로운 기록은 새로우 파일에 추가한다.
- 따라서 생성되면 변경되지 않으므로
	- 모든 참조가 동시에 접근될 수 있고
	- 수정될 수 없다는 사실 자체가 데이터의 무결성을 보장한다.

## 데이터 처리 방식의 차이
- 내부적으로는 불변 파일은 여러 사본을 가질 수 있고, 최신 사본이 이전 사본을 덮어쓴다.
	- 반면 가변 파일은 최신 값만 보관한다.
- 외부적으로는 불변 파일에 접근할 때는 파일들이 처리되고, 중복된 사본들은 조정되며, 가장 최신 값들이 클라이언트에게 반환된다.

## B-tree VS LSM tree
- 대표적인 가변 구조가 B-tree이다.
	- B-tree는 디스크에서 데이터 레코드를 찾아서 파일의 원래 오프셋에서 페이지를 업데이트한다.
- 대표적인 불변 구조가 LSM tree이다.
	- 불변 LSM tree는 append-only방식의 저장과 merge-reconciliation방식을 사용한다.

## 읽기 성능 vs 쓰기 성능?
- B-tree와 같은 In-place update저장 구조는 읽기 성능에 최적화되어있다.
	- 디스크에서 데이터를 찾으면 즉시 클라이언트에 반환될 수 있다.
	- 하지만 쓰기 성능이 희생된다.
		- 왜냐면, 데이터를 제자리에서 업데이트하려면 먼저 디스크에서 해당 레코드를 찾아야하기 때문이다.
- LSM tree와 같은 append-only저장 구조는 쓰기 성능에 최적화되어있다.
	- 기록을 덮어쓰기 위해 디스크에서 레코드를 찾을 필요 없이, 단순히 새로운 내용을 추가하기만 하면 된다.
	- 하지만 읽기 성능이 희생된다.
		- 여러 데이터 레코드 버전을 검색하고, 이를 조정해야하기 때문이다.

## B-tree의 문제점과 LSM Tree를 이용한 해결책
- 가변 B-tree는 대부분의 I/O 작업이 **랜덤 I/O** 이다.
	- 즉, 데이터 레코드를 포함하는 페이지를 직접 찾아서 수정해야한다.
	- -> 불변 구조인 LSM tree에서는 I/O 작업을 순차적으로 만들어서 해결한다.
- 그리고 노드의 분할 및 병합이 요구될 수 있다.
- 그리고 페이지 내의 한 셀만 수정되어도 전체 페이지를 다시 써야한다.
	- **디스크는 페이지(블록) 단위로 쓰기/읽기를 수행하기때문!**

> 대부분의 RDBMS는 B-Tree 기반의 가변 구조를 사용하지만, NoSQL 데이터베이스는 LSM Tree기반의 불변 구조를 많이 사용한다.
> 그 이유는, DB가 읽기를 많이 하는지, 쓰기를 많이 하는지에 따라서 적절한 tree기반이 선택된 것 같다. 읽기 작업이 많으면 B-tree 기반을 사용하고, 쓰기 작업이 많으면 LSM tree기반을 선택하는것이 적절하다.

# LSM Trees(로그 구조형 병합 트리)
: LSM Tree는 버퍼링과 append-only저장 방식을 사용해서 순차적 쓰기를 한다.
긜고 LSM Tree는 B-tree와 달리 노드가 완전히 채워져 있으며, 순차적인 디스크 접근에 최적화되어있다.

## LSM Tree의 작동 방식
: 요약하면 다음과 같은 4단계를 거친다.
1. 사용자가 데이터를 삽입함 → **MemTable(Memory-Resident Table)** 에 추가됨.
2. 일정 시간이 지나거나 용량이 가득 차면 → **디스크에 SSTable(Sorted-String Table)로 flush**됨.
3. 시간이 지나면서 SSTable이 여러 개 쌓임 → **Compaction으로 병합 및 정리**.
4.  읽을 때는 **MemTable → WAL → SSTables 순으로 탐색**, 최신 값을 찾아냄.

- **데이터 쓰기** : LSM tree는 데이터 파일 쓰기를 지연시키고, 변경사항을 위에 나온 MemTable에 버퍼링한다. 
- **순차적 쓰기** : 그리고 이 데이터들은 디스크에 한번에 쭉 쓰여지며, 파일은 append-only이다. 이렇게 데이터 레코드를 순차적으로 배치해서 단편화(fragmentation)을 방지할 수 있다.
- **쓰기 성능** : 파일이 불변이므로 삽입(=추가), 업데이트(=추가와 같은 과정), 삭제(추후에 배울 tombstone 으로 처리리)작업은 디스크에서 레코드를 찾을 필요가 없다. 이는 쓰기 성능과 처리량을 크게 향상시킨다.
- **동시성 제어** : B-tree는 무결성을 보장하기 위해서 locks와 latches를 사용하지만, LSM tree는 segment locking없이 읽고 쓸 수 있어서 동시 접근을 크게 단순화시킨다.
- **유지 보수** : LSM tree에서의 Merge는 유지 보수 중에 중복된 사본이 차지하는 공간을 회수하기 위해서 발생한다(**파일 수가 꾸준히 증가**하기 때문에, **읽기 시 접근하는 파일 수를 최소화**하기 위해 파일들을 **병합하고 재작성**해야한다). 그리고 읽기 중에도 내용을 사용자에게 반환하기 전에 발생한다.
	- B-tree는 단편화를 줄이고, 공간을 회수하기 위해 재작성(= merge, split)이 필요하다.
## Two-component LSM Tree
: 디스크 접근을 최소화해서 쓰기 성능을 극대화시킨 구조의 Tree이다.
이름 그대로 두 개의 계층(메모리와 디스크)만 사용한다.

1. Memory-resident Tree (메모리 상 트리)
	1. 데이터를 먼저 메모리에 저장하고, 일정 크기가 되면 디스크로 flush한다.
2. Disk-resident Tree (디스크 상 트리)
	1. 디스크에 있는 immutable한 B-Tree이다.
	2. 이 B-Tree의 노드는 100% 채워져 있고, 읽기 전용이다.

### 쓰기 Flushing 과정
- 메모리에 있던 트리를 디스크로 옮기기 위해 디스크 상의 해당 서브트리와 병합한다.
- 병합 결과는 디스크의 새로운 세그먼트에 저장된다.
- 병합이 끝나면 이전 메모리/디스크 트리는 버리고, 새로운 병합 결과만 사용한다.
### 병합 과정
- 정렬된 두 데이터(메모리 트리와 디스크 트리)를 동시에 순회하며 병합한다.
- 정렬된 두 리스트를 합치는 merge sort와 같은 방식이다.
- 이를 통해 병합한 결과도 정렬 상태로 유지가 가능하다.
### 병합 및 플러싱 할 때 보장해야 할 3가지
1. 플러싱 프로세스가 시작되는 즉시, **모든 새로운 쓰기는 MemTable로 들어가**야 한다.
2. **읽기 접근성 유지** : 병합 중에도 기존 메모리 트리와 디스크 트리 모두 읽기가 가능해야 한다.
3. **원자적(Atomic) 작업** : 플러싱 후, 병합된 내용을 게시하고 병합되지 않은 디스크 및 메모리 상주 내용을 폐기하는 작업은 원자적으로 수행되어야 한다. 즉, 모든 과정이 한 번에 성공하거나 실패해야 하며 중간 상태가 외부에 노출되어서는 안된다.

- 쓰기 성능을 위해 설계됐지만, **memtable flush가 자주 발생하면 병합이 잦아지고, write amplification(쓰기 증폭)**이 심해짐.
- 그래서 **실제 구현한 시스템은 알려진 게 없음** (책 작성 시점 기준).

## Multicomponent LSM Tree(다중 컴포넌트 LSM 트리)
: 2-component LSM 트리와는 달리, **하나 이상의 디스크 상주 테이블**을 가진다.
- 특징 : 전체 멤테이블의 내용이 한번의 작업으로 디스크에 플러싱된다.
	- 그리고 여러번 플러싱을 수행하면, 여러개의 디스크 상주 테이블(Disk-resident tables)이 생기고, 그 수는 계속 증가하게 된다.
- 읽기 비용 증가 문제 : 찾으려는 데이터를 찾기 위해 여러 파일에 접근해야 할 수 있다.
- **Compaction을 통한 문제 완화**
	- (자세한 내용은 Maintenance in LSM Trees에서 다룰예정)
	- 요약하면, 여러 테이블을 선택해서 그 내용을 읽고, 병합하고, 병합한 결과를 새로 결합된 파일로 디스크에 플러싱한다.

<img width="1032" height="330" alt="image" src="https://github.com/user-attachments/assets/bc581726-6ab2-4fe2-8d75-c32dcfa42208" />

### LSM tree의 life cycle
1. 데이터는 Memtable에 버퍼링된다.
2. 멤테이블의 크기가 너무 커지면, 그 내용은 디스크로 플러싱되어 디스크 상주 테이블(SSTable)을 생성한다.
3. 여러 디스크 상주 테이블이 병합되어 더 큰 테이블을 생성한다.
	- 이 과정을 통해 파일의 수가 관리되고, 중복되거나 오래된 데이터가 정리된다.

## In-memory tables(Memtable)
: LSM Tree의 핵심 구성 요소 중 하나인 Memtable에 대한 내용이다.

- **언제 Memtable이 Flush됨?** : 주기적으로 또는 Memtable크기 임계값에 도달했을 때 트리거된다.
- **플러싱 전 멤테이블의 전환 과정**
	1. 플러싱을 시작하기 전에 새로운 멤테이블이 할당된다.
	2. 이 새로운 멤테이블은 모든 새 쓰기 작업의 대상이 된다.
	3. 기존 멤테이블은 "플러싱 상태"로 전환된다.
	4. 위의 단계는 atomically(원자적)으로 수행되어야한다.(데이터 일관성을 보장하기 위함)
- 플러싱 중인 멤테이블은 그 내용이 **디스크에 완전히 쓰여질때까지 읽기 작업에 계속 사용 가능**하다.
- 플러싱이 완료되고 새로운 상주 테이블이 생성되면, **이전 멤테이블은 폐기**되고 **새로운 디스크 상주 테이블이 읽기 작업에 사용 가능**하게 된다.

<img width="1028" height="493" alt="image" src="https://github.com/user-attachments/assets/7cf47c3b-6ad8-4aed-8eda-61bf6e06b370" />


위 그림은 다양한 컴포넌트들과의 관계와 컴포넌트들 사이의 전환을 나타낸다.
- **Current Memtable** : 새로운 쓰기 작업을 받고, 읽기 요청을 처리한다. 모든 최신 데이터 변경사항이 여기에 먼저 기록된다.
- **Flushing memtable** : 디스크로 플러싱중인 멤테이블이다. 이 과정 중에도 읽기 작업은 가능하다.
- **On-disk flush target** : 멤테이블의 내용이 **순차적으로**기록되고 있는 디스크 상의 새로운 파일이다. 아직 불완전한 상태이므로 읽기가 불가능하다.
- **Fluched tables** : 멤테이블에서 디스크로 플러싱이 완료된 후 생성되는 **불변**파일이다. 플러싱 중인 멤테이블이 폐기된 후 즉시 읽기가 가능하다.
- **Compacting tables** : 현재 병합(=Compaction)되고 있는 디스크 상주 테이블이다. 여러 개의 테이블이 큰 하나의 테이블로 합쳐지느ㅡ 과정에 있다.
- **Compacted tables** : 플러싱 완료된 테이블이나 병합됭 생성된 새로운 테이블이다. 불변이며 읽기 작업에 사용된다.

> 플러싱이 진행되는 동안, 플러싱 중인 멤테이블과 현재의 멤테이블 모두 읽기 작업이 가능하다. 따라서, 쓰기 작업 중에도 문제없이 지속적으로 읽기 작업이 가능하다!!

### WAL(Write-Ahead Log)과 Memtable의 관계
- 멤테이블이 완전히 플러싱될 때까지, WAL에 저장된다(그 내용의 유일한 디스크 상주 버전만).
- 즉, 메모리의 멤테이블 내용이 유실된다면, WAL을 이용해 복구가능하다.
- 플러싱 된 후, 로그를 trim(불필요한 부분을 잘라내는 작업)할 수 있다.
- 이는 WAL이 무한정 커지는 것을 방지하고 효율적인 로그 관리를 가능하게 한다.

## Updates and Delete
: 위에서도 나온거같긴한데 삽입, 업데이트, 삭제 작업은 데이터 레코드를 찾을 필요가 없다. 중복된 레코드는 읽기 과정에서 조정된다.

- '삭제됨' 표시를 하는것이 아닌, 단순 삭제의 문제점?
	- 만약 멤테이블에서 항목을 제거하는 방식으로 삭제를 구현한다면, 결국 아무 영향도 주지 않거나 기존 값을 부활시킬수도 있다.
- 위 상황에 대한 예시를 보자.
```
Disk Table   Memtable
| k1 | v1 | | k1 | v2 |
이 상태에서 Memtable의 데이터만 삭제한다면...

Disk Table   Memtable
| k1 | v1 |     ∅
k1에 연결된 유일한 값이 Disk Table의 v1이 되므로 사실상 v1을 부활시키는 결과가 나온다.
```
- 따라서 **삭제는 명시적으로 기록되어야**한다.
	- 이는 데이터 레코드의 제거를 나타내는 표시를 해줘야한다.
	- tombstone 또는 dormant certificate라고 불린다.
```
 Disk Table       Memtable
| k1 | v1 |  | k1 |<tombstone>|
```
- 이렇게 tombstone처리를 할 수 있다.
- 조정 과정에서 툼스톤을 발견하면, 툼스톤에 의해 가려진 값들은 걸러져스 클라이언트에게 반환되지 않는다.

### Predicate Deletes
: 단일 키가 아닌 연속된 키 범위를 제거하는 것이다.
정렬되는 프레디케이트(조건)을 가진 삭제 엔트리를 추가하는 방식으로 작동한다. 잘 모르겠으니 예시를 보자.
<img width="669" height="146" alt="image" src="https://github.com/user-attachments/assets/15a965fb-698c-428b-a9d8-9e808291a4bb" />
- DELETE FROM table WHERE key ≥ "k2" AND key < "k4"
- 이와 같은 조건과 일치하는 데이터 레코드는 건너뛰고 클라이언트에게 반환되지 않는다(위에서는 k2와 k3가 가려짐).
- 범위 툼스톤을 사용할 때는 중복되는 범위와 디스크 상주 테이블 경계 떄문에 규칙(프레디케이트)을 신중하게 고려해야한다.

## LSM Tree 조회 (Lookups)

LSM Tree는 여러 개의 컴포넌트로 구성되어 있다. 데이터를 조회(lookup)할 때는 일반적으로 **두 개 이상의 컴포넌트에 접근**하게 된다. 이렇게 여러 컴포넌트에서 가져온 내용은 클라이언트에게 반환되기 전에 **병합되고 조정(reconciled)되어야** 한다.

---
## Merge-Iteration
: LSM tree에서 데이터를 조회할 때, 여러 컴포넌트(멤테이블, 디스크 테이블)에 흩어진 데이터를 효율적으로 합치기 위해 **다중 병합 정렬(multiway merge-sort)** 알고리즘을 사용한다.

### 다중 병합 정렬
- 우선순위 큐를 사용한다 - 최소힙 자료구조 활용
	- (다음으로 반환될 가장 작은 요소가 항상 큐의 맨 앞에 오도록 준비한다.)
- 병합 과정의 단계
1.  **가장 작은 요소 제거** : 큐의 헤드(가장 작은 요소)가 제거된다.
2.  **다음 값 삽입** : 제거된 요소와 연결된 iterator에서 다음 값을 가져와 큐에 다시 배치한다.
3. **큐 재정렬** : 큐는 다시 정렬되어 순서를 유지한다.
4. (만약 iterator이 더 이상 반환할 값이 없다면, 다음 iterator 헤드를 재삽입하지 않고 알고리즘이 진행된다.)

```
> 이렇게 보니 잘 모르겠다. 걍 책에 나와있는 알고리즘 예시를 보자. 알고리즘은 예시를 한번 보는게 이해하기 가장 좋은 방법인것 같다.
> (예시)
> iterator 1 = {k2 : v1}, {k4: v2}
> iterator 2 = {k1 : v3}, {k2: v4}, {k3: v5}
> priority queue = x
> result = x
> 위와 같이 정렬된 iterator 2개와 빈 우선순위 큐, 병합된 결과인 result가 있다.
```

1. **우선순위 큐 초기 채우기** : 각 이터레이터의 헤드를 우선순위 큐에 넣는다.
```
> iterator 1 = {k4: v2}
> iterator 2 = {k2: v4}, {k3: v5}
> priority queue = {k1 : v3}, {k2 : v1}
> result = x
```
2. **가장 작은 요소 처리** 후 **큐 리필**
	1. 가장 작은 요소 처리 : 우선순위 큐에서 가장 작은 키인 {k1 : v3}을 result에 추가한다.
	2. 큐 리필 : {k1 : v3}은 iterator 2에서 왔으므로, iterator 2에서 현재 가장 작은 키인 {k2: v4}을 꺼내서 우선순위 큐에 저장한다.
 ```
> iterator 1 = {k4: v2}
> iterator 2 = {k3: v5}
> priority queue = {k2 : v1}, {k2: v4}
> result = {k1 : v3}
```
3. 동일 키 레코드 처리 후 큐 리필
	1. 우선순위 큐를 보면 키값이 같은 k2인 레코드가 2개 있다.
	2. 이 둘을 비교해, **가장 최신 값**인 v4를 선택해 병합된 결과인 result에 추가한다.
	3. 큐 리필 : 위의 '동일 키 레코드'처리가 끝나면, 우선순위 큐에 있던 레코드를 제공한 이터레이터에서 다음 항목을 가져와서 큐를 리필하고, 정렬한다.(위의 2-2 과정과 동일한 알고리즘이지만, 여기서는 동일 키 레코드이므로 v1과 v4를 제공해준 iterator1, iterator 2에서 모두 레코드를 받아온다.)
```
> iterator 1 = x
> iterator 2 = x
> priority queue = {k3: v5}, {k4: v2}
> result = {k1 : v3}, {k2: v4}
```
4. 남은 큐 내용 처리
: 모든 이터레이터가 비어있으므로, 큐에 남아있는 모든 내용을 result에 순서대로 추가해주면 된다.
```
> iterator 1 = x
> iterator 2 = x
> priority queue = x
> result = {k1 : v3}, {k2: v4}, {k3: v5}, {k4: v2}
```
**Merge-Iteration 과정이 끝났다!!!!**
요약해서 정리해보자.
1. 초기 채우기 : 이터레이터의 첫번째 항목들로 우선순위 큐를 채운다.
2.  최소 요소 추출 : 큐에서 가장 작은 요소(=헤드)를 가져온다. 이 요소를 최종 결과에 추가하거나, 동일 키 레코드 조정 시 사용한다.
3. 큐 리필 : 방금 추출된 요소가 속했던 이터레이터에서 다음 항목을 가져와 큐에 다시 넣고 큐를 재정렬한다.
	1. 단 이터레이터가 비어있다면, '최소 요소 추출' 과정을 반복한다.
## Reconciliation - 조정
: 서로 다른 테이블에 동일한 키에 대한 데이터가 존재할 수 있다.(위 예시에서 같은 k2 키에 v1, v4가 나온거처럼) 이런 내용들은 **조정**되어야 한다.
### 조정 방법
: 어떤 레코드가 우선권을 가지는지를 알아야 한다.
- 데이터 레코드는 이를 위해 **타임스탬프(timestamps)**와 같은 필요한 메타데이터를 가지고 있다.
- 이 '타임스탬프'를 비교해서, 가장 최신 타임스탬프를 가진 레코드가 우선권을 가진다.
- 높은 타임스탬프를 가진 레코드에 의해 가려진 레코드들(위에서 v1과 v4에서 v1이 가려진 상태임)은 클라이언트에게 반환되지 않거나, 컴팩션 과정에서 디스크에 다시 쓰여지지 않는다. 즉, 제거된다.

### Upsert(업서트)개념
: 간단하게 레코드가 존재하지 않으면 삽입하고, 존재하면 기존 레코드를 업데이트하는 연산을 의미한다.
- 전에 말했듯이, LSM tree에서는 insert와 update작업이 서로 구별되지 않는다. - 일단 메모리에 박아두기때문
- 따라서 **LSM tree는 upsert한다**고 말할 수 있다.
	- 새로운 키가 들어오면 삽입이 되고, 기존 키에 대한 업데이트가 아닌 **새로운 레코드가 추가되는 방식**으로 동작하기 때문이다.
	- 최종 결과는 읽기 시 조정 과정을 통해 결정된다.
