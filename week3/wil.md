# B-Tree Basics
> 내가 알고리즘을 깔짝 공부할때 조금 다뤄봤던 트리와 관련된 내용인 것 같다. 트리라는 단어를 보니 우선순위 큐, 그래프 탐색 등이 생각나네...

## Binary Search Trees
BST는 효율적인 키-값 조회를 위해 사용되는 정렬된 인메모리 데이터 구조이다. 라고는 하는데 책을 읽어보니 부모 노드의 값보다 작은값은 좌측에 저장되고, 큰 값은 우측에 저장되는. 그리고 자식은 최대 2개만을 가질수 있는 그러한 자료구조로 생각하면 될거같다. 그리고 단 하나의 루트 노트에서 시작된다는 점을 생각하고 머리속으로 그래프 구조를 그려보니 이해가 편했다.
![image](https://github.com/user-attachments/assets/e1d58de3-7220-481b-8945-540cd1737606)

### 트리 균형 맞추기
데이터를 삽입하는 과정은 특정 패턴을 따르지 않는다. 따라서 b)와같이 트리가 불균형해지는 상황으로 이어질 수 있다. 이때는 시간복잡도가 O(log N) 을 따르는게 아니라 최악의 경우 O(N)의 선형 시간복잡도를 가지게 된다. 
![image](https://github.com/user-attachments/assets/15971a98-eff5-405a-b1b0-8eae409d3bb9)
위 사진은 최악의 상황을 보여주지만, 트리의 균형을 맞춰줘야 하는 이유를 보여준다.

균형 맞추기를 할 때는 트리 높이를 최소화하고, 각 측면의 노드 수를 범위 내로 유지하는 방식으로 노드를 재구성한다.
그 방법중 하나로 **회전 단계**를 수행한다. 
![image](https://github.com/user-attachments/assets/bbe7b60a-6df8-4388-9865-fe8f6e0794c7)
위 사진처럼 가지의 연속된 두 노드가 자식을 하나만 가지고 있는 경우, 중간 노드를 회전축으로 기존의 부모와 자식 노드들이 회전축의 자식 노드가 된다.

## Trees for Disk-Based Storage
위와 같은 높은 시간복잡도를 가지는 불균형 트리는 낮은 팬아웃(Fanout, 노드당 허용하는 최대 자식 수, BST는 2의 팬아웃을 가진다)으로 인해 균형 맟추기, 노드 재배치, 포인터 업데이트 등을 자주 수행해야 한다. 이러한 증가된 유지 관리 비용은 BST를 온디스크 데이터 구조로 사용하기에는 비효율적으로 만든다.

- BST를 디스크에 유지관리하려면 지역성(locality)문제에 직면한다.
	요소들이 임의의 순서로 추가되므로 새로 생성된 노드가 부모 노드 가까이에 기록된다는 보장이 없다. 그러면 데이터가 여러 디스크 페이지에 걸쳐 있을 수 있음을 의미한다.
- 트리 높이에 대한 문제도 발생할 수 있다.
	BST의 트리 높이는 log2(N) 이므로 검색된 요소를 찾기 위해 log2(N)번 디스크에 접근해야한다. 그러면 높은 팬아웃을 가지는 구조에 비해서 더 많은 디스크 I/O가 발생한다.
	반면에 책에서 인메모리 데이터 구조에서는 유용하다고 했는데, 그 이유는 인메모리 데이터 구조에서는 log2(N)의 속도로 탐색이 가능하고, 랜덤 접근 속도가 디스크보다 훨신 빠르므로 더 유용하다.
위 같은 점을 고려할때, 디스크에 적합한 트리 버전은 다음ㅇ과 같은 속성을 나타내야한다.
- 이웃 키의 지역성을 향상시키기 위한 높은 팬아웃
- 순회 중 탐색 횟수를 줄이기 위한 낮은 높이
	+팬아웃과 높이는 반비례 관계이다. 팬아웃이 높다는것은 자식 노드가 많이 있을 수 있어서 높이가 줄어든다.

## Disk-Based Structures
전체 데이터들을 메모리에 보관하는것이 불가능하거나 실현가능하지 않을 정도로 데이터의 양이 매우 클때 온디스크 데이터 구조가 사용된다. 저장된 데이터들 중 일부만 메모리에 캐싱되고, 나머지는 효율적인 방법으로 액세스할 수 있는 방법으로 저장되어야 한다.

### HardDiskDrives
HDD(하드) 라고 불리는 익숙한 그거다. HDD에서는 디스크 회전과 읽기/쓰기 헤드를 원하는 위치로 이동시키기 위한 물리적인 움직임이  필요하기 때문에 임의 읽기 비용을 증가시킨다. 그러나 비용이 많이 드는 부분이 끝나고 연속적인 바이트(순차 작업)를 읽거나 쓰는 비용은 비교적 저렴하다.

### SolidStateDrives
일반적인 SSD는 메모리 셀로 구성되며, 이 셀들은 문자열(string, 일반적으로 문자열당 32~64개의 셀) 로 연결되고, 문자열은 배열로 결합되며, 배열은 페이지로 결합되고, 페이지는 블록으로 결합된다. 최종적으로 아래와 같은 계층 구조를 가진다.
![image](https://github.com/user-attachments/assets/ae3052ff-1ceb-4fc3-9331-80da25d185c4)
SSD에서 읽기 또는 쓰기가 가능한 가장 작은 단위는 페이지이다.
- 가장 작은 삭제 단위는 페이지가 아니라 페이지의 조합인 블록이다.
- 페이지의 주소를 물리적 위치에 매핑하고, 비어 있거나, 쓰여졌거나, 폐기된 페이지를 추적하는 플래시 메모리 컨트롤러의 부분을 플래시 변환 계층(FTL, Flash Translation Layer)이라고 한다.
	- 안전하게 삭제할 수 있는 블록을 찾는 GC담당을 한다(라이브 페이지가 포함될 경우 블록에서 라이브 페이지를 재배치하고, 사용되지 않는 블록을 삭제하여 쓰기에 사용할 수 있도록함).
- 블록 장치 추상화 : 내부 디스크 구조를 숨기고 I/O 작업을 내부적으로 버퍼링하므로 블록 장치에서 단일 단어를 읽을 때, 해당 단어가 포함된 전체 블록이 읽힌다. 이는 디스크 상주 데이터 구조로 작업할 때, 항상 고려해야하는 제약 조건이다.
- SSD에서는 Random 과 sequential I/O의 차이가 크지 않다.
- 전체 블록만 쓰고 동일한 블록에 대한 후속 쓰기를 결합하면 필요한 I/O작업 수를 줄이는 데 도움이 될 수 있다(버퍼링과 불변성으로 달성할 수 있다).

## On-Disk Structures
- 효율적인 온디스크 구조를 만들기 위해서는 '디스크 작업의 가장 작은 단위가 블록이라는 사실'을 기억해야 한다. 
- 온디스크 구조는 대상 스토리지의 특성을 염두에 두고 설계되며, 일반적으로 더 적은 디스크 액세스를 위해 최적화된다.
	- 이는 지역성을 개선하고, 구조의 내부 표현을 최적화하고, 페이지 외부 포인터 수를 줄임으로써 수행할 수 있따.
- 위의 BST에서 높은 팬아웃과 낮은 높이가 온디스크 구조에 바람직하다는 결론을 냈고, 포인터로 인한 추가 공간 비용과 균형 조정으로 인한 재매핑의 추가 비용에 대해서도 생각해봤다. **B-Tree는 이러한 아이디어를 결합**한다. 즉 **노드 팬아웃을 늘리고, 트리 높이, 노드 포인터 수 및 균형 조정 작업 빈도를 줄인다**.

### +Paged Binary Trees
![image](https://github.com/user-attachments/assets/f992e5cb-6edc-4962-9d52-33dd28070969)
위와같이 노드를 페이지별로 그룹화해서 지역성을 개선시킨 구조이다.

## Ubiquitous B-Trees
(-> 널리 사용되는 B-Tree들에 대한 내용이다. 수업 끝나고 계속하기..)
