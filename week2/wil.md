# Column- Versus Row-Oriented DBMS
> 컬럼 지향 DBMS와 로우 지향 DBMS를 비교해보는 챕터이다. 이는 데이터베이스르 분류하는 한 가지 방법중 하나인 데이터가 디스크에 저장되는 방식에 따라서 구분한것이다. 

- 로우 지향 DBMS의 예시로는 많이 들어본 MySQL이나 PostgreSQL가 있다. 컬럼 지향 DBMS의 예시로는 처음 들어본 MonetDB와 C-Store가 있다.
## Row-Oriented Data Layout
- 로우 지향 데이터베이스 시스템은 데이터를 레코드 또는 로우 단위로 저장한다. 내가 알고있는 익숙한 방식이다.
- 이는 여러 필드가 키로 고유하게 식별되는 레코드를 구성할 때 잘 작동한다. 
- 로우별로 데이터에 접근할때 가장 유용하므로, 전체 로우를 함께 저장하면 **공간 지역성**이 향상된다.
	- 공간 지역성이란, 컴퓨터 메모리에서 데이터를 저장할 때 **인접한 데이터끼리 묶어서 저장하면 접근 속도가 빨라지는 특성**을 의미한다.
	- 컴퓨터 메모리는 데이터를 저장할 때 캐싱을 하는데, 캐싱을 하면 접근한 데이터와 그 주변 데이터를 미리 가져와서 속도를 높이는 역할을 한다. 따라서 로우별로 저장하면 해당 로우의 데이터가 모두 근처에 저장되어있어서 메모리에서 빠르게 불러올 수 있다. 따라서 검색 속도가 빨라지는 효과가 있다.
- 디스크는 일반적으로 블록 단위로 데이터를 불러오므로(저번 시간에 배운내용) 블록에는 모든 컬럼에 대한 데이터가 포함된다. 이때 전체 사용자 레코드를 액세스할때는 좋지만, 몇몇의 개별 필드를 액세스하는 쿼리는 다른 필드의 데이터도 함꼐 가져오므로 비용이 더 많이든다(낭비된다).

## Column-Oriented Data Layout
컬럼 지향 데이터베이스 시스템은 데이터를 수직으로 분할한다. 즉, 동일 한 컬럼의 값들이 디스크에 연속적으로 저장된다.
- 다른 컬럼의 값을 별도의 파일이나 파일 세그먼트에 저장하면 컬럼별 쿼리가 효율적입니다.
	- 이는 각 컬럼을 별도의 파일로 저장하면 특정 컬럼에 대해서 쿼리를 실행할 때, 해당 파일만 불러오고 다른 파일(컬럼)을 불러올 필요가 없어서 효율적이라는것이다.
- 이런 특징들때문에 컬럼 지향 저장소는 추세 찾기, 평균값 계산 등과 같은 데이터 분석이 필요할 때 적합하다.

## Distinctions and Optimizations
- 동일한 컬럼의 여러 값을 한 번에 읽으면 캐시 활용률과 계산 효율성이 크게 향상된다.
- 동일한 데이터 타입의 값을 함께 저장하면 압축률이 향상된다.
- 어떤 형태의 저장소를 사용할지 결정하려면 **액세스 패턴**을 이해해야 한다.
	- 데이터가 레코드 단위로 사용되고, 주로 포인트 쿼리 및 범위 스캔으로 구성된 경우는 로우 지향 접근 방식이 나을 확률이 높다.
	- 스캔이 많은 로우에 걸쳐 있거나, 컬럼의 하위 집합에 대한 집계를 계산하는 경우는 컬럼 지향 접근 방식을 고려하면 좋다.
## Wide Column Stores
```Bash
RowKey: 101
--------------------------
name → "김철수"
age → 30
phone → "010-1234-5678"
address → "서울특별시"

RowKey: 102
--------------------------
name → "이영희"
address → "부산광역시"

RowKey: 103
--------------------------
name → "박지훈"
age → 27
phone → "010-9876-5432"
```
와이드 컬럼 저장소란 위와같이 각 행별로 필요한 컬럼만 저장 가능한 저장소이다. MySQL같은 관계형 DBMS에서는 모든 행이 같은 컬럼을 가져야만하므로 데이터가 비어있다면 해당 컬럼에 NULL값을 넣어줘야만 한다.
- Wide Column Stores 과 Webtable에 대한 내용은 일단 Pass.
# Data Files and Index Files
 데이터베이스 시스템에서 일반 파일보다 특수 파일 구성일 사용하는 주된 이유 3가지
1. 저장 효율성
	- 저장된 데이터 레코드당 스토리지 오버헤드를 최소화하는 방식으로 파일이 구성된다.
	- 스토리지 오버헤드란? 데이터를 저장할 때, 실제 데이터 외에 추가적으로 필요한 공간을 의미한다. 메타데이터(데이터를 관리하기 위해 필요한 추가 정보들), 인덱스, 중복 데이터 등이 있다.
2. 액세스 효율성
	- 가능한 가장 적은 단계로 레코드를 찾을 수 있다.
3. 업데이트 효율성
	- 디스크 변경 횟수를 최소화하는 방식으로 레코드 업데이트가 수행된다.

- 데이터베이스 시스템에서 각 테이브은 일반적으로 별도의 파일로 저장된다.
- 인덱스는 레코드를 식별하는 필드의 하위 집합을 사용하여 빌드된다. -> 검색이나 정렬에 자주 사용되는 필드값을 인덱스로 설정할 수 있다는것
- 데이터베이스 시스템은 일반적으로 데이터 파일과 인덱스 파일을 분리한다.
	- 데이터 파일은 레코드를 저장하고, 인덱스 파일은 레코드의 메타데이터를 저장하고 사용해서 데이터 파일의 레코드를 찾는다.
- 최신 스토리지 시스템 대부분은 페이지에서 데이터를 명시적으로 삭제하지 않는다.
	- 삭제 마커(delete = true 와 같은것..)를 사용해서 데이터를 '삭제됨' 상태로 두고 실제로 삭제는 안 된 상태.
	- 이후 GC에 의해 정리된다.

## Data Files
데이터 파일(기본 파일)은 인덱스 구성 테이블(Index-Organized Table, IOT), 힙 구성 테이블(Heap-Organized Table, 힙 파일), 해시 구성 테이블(해시 파일)로 구현될 수 있다.
- **힙 파일**의 레코드는 특정 순서를 따를 필요 없이 대부분 쓰기 순서대로 배치된다. -> 데이터 삽입 속도는 빠르지만, 인덱스가 없으면 모든 행을 검사해야하므로 검색 속도가 느려질 수 있다. -> 데이터 레코드가 저장된 위치를 가리키는 추가 인덱스 사용해서 문제해결
- **해시 파일**은 레코드가 버킷(데이터를 저장하는 공간)에 저장되고, 키값에 따른 해시의 값에 따라서 버킷이 결정된다. 같은 해시 값을 가지면 같은 버킷을 공유해서 충돌이 발생할 수 있지만, 연결리스트를 사용해서 해결할 수 있다.
- **인덱스 구성 테이블**은 인덱스 자체에 데이터 레코드를 저장한다. 레코드가 키 순서대로 저장되므로 검색 성능을 최적화할 수 있다.
	- 검색된 키를 찾은 후 연결된 데이터 레코드를 찾기 위한 별도의 과정이 없으므로 디스크 탐색 횟수를 최소한 한번 줄일 수 있다.


## Index Files(중요)
- 인덱스 파일은 키를 해당 키로 식별되는 레코드 또는 기본 키가 저장된 데이터 파일의 위치에 매핑하는 구조로 구성된다.

- 데이터 파일에 대한 인덱스를 기본 인덱스라고 한다.
- 그러나 대부분의 경우 기본 인덱스는 기본 키 또는 기본으로 식별된 키 집합 위에 빌드된다고 가정할 수도 있다. -> 학번과 같은 Primary Key를 기준으로 기본 인덱스를 생성한다고 해석하면 될듯?
- 보조 인덱스는 데이터 레코드를 직접 가리키거나 단순히 기본 키를 저장할 수 있다.
- 기본 인덱스 파일은 검색 키당 고유한 항목을 보유하지만, 보조 인덱스는 검색 키당 여러 항목을 보유할 수 있다.
- 데이터 레코드의 순서가 검색 키 순서를 따르는 경우, 이 인덱스를 **클러스터형**이라고 한다.
	- 이 경우 데이터 레코드는 일반적으로 동일한 파일 또는 키 순서가 유지되는 클러스터형 파일에 저장된다.
- 반대로 데이터가 별도의 파일에 저장되고 순서가 키 순서를 따르지 않는 경우 인덱스를 비클러스터형 이라고 한다.
![[Pasted image 20250506200606.png]]
- a의 경우는 두 개의 인덱스가 보조 인덱스 파일에서 직접 데이터 항목을 참조한다.
- b의 경우는 보조 인덱스가 데이터 항목을 찾기 위해 기본 인덱스의 간접 계층을 통과한다.(기본 인덱스의 간접 계층을 통과한다는것이 뭔소리인지 모르겠다)

- 인덱스 구성 테이블(a의 경우)은 정보를 인뎃스 순서대로 저장하며 클러스터형이다. 기본 인덱스도 대부분 클러스터형이다. 보조 인뎃스는 기본 키 이외의 키로 액세스를 용이하게 하는 데 사용되므로 비클러스터형이다.
- 많은 데이터베이스 시스템에는 데이터베이스 레코드를 고유하게 식별하는 컬럼 집합인 고유하고 명시적인 기본 키가 있다.
	- 기본 키가 지정되지 않은 경우 스토리지 엔진은 암시적 기본 키를 생성할 수 있다.

## Primary Index as an Indirection
(간접 참조로서의 기본 인덱스)

- 데이터 레코드를 직접 참조하는 것 또는 기본 키 인덱스를 통해 참조하는 것 이 두 방식이 있다.

- 데이터를 직접 참조하면 디스크 탐색 횟수를 줄 일 수 있지만, 레코드를 업데이트하거나 재비치될 떄마다 포인터를 업데이트하는 비용을 지불해야한다.
- 기본 인덱스 형태의 간접 참조를 사용하면 포인터 업데이트 비용을 줄일 수 있지만, 읽을 때 비용이 더 많이 든다.
- 워크로드가 대부분 읽기로 구성된 경우는 몇 개의 인덱스만 업데이트하는 것이 효과적일 수 있지만, 여러 인덱스가 있는 쓰기 집약저인 워크로드에는 적합하지 않다.
- 포인터 업데이트 비용을 줄이기 위해 일부 구현에서는 페이로드 오프셋(데이터 패킷에서 실제 데이터(페이로드)가 시작되는 위치) 대신 기본 키를 간접 참조에 사용한다.
	- MySQL이나 InnoDB는 기본 인덱스를 사용하고 쿼리를 수행할 때, 보조 인덱스에서 한번, 기본 인덱스에서 한번, 총 두 번의 조회를 수행한다.
	- 이는 보조 인덱스에서 직접 오프셋(데이터베이스에서 오프셋은 특정 위치에서 데이터를 검색할 때 건너뛸 행(row)의 개수)을 따르는 대신 기본 인덱스 조회 오버헤드(추가적인 비용)를 추가한다.

![[Pasted image 20250506201944.png]]
- a의 경우(데이터 튜플 직접 참조)는 두 개의 인덱스가 보조 인덱스 파일에서 직접 데이터 항목을 참조한다.
- b의 경우(기본 인덱스를 간접 참조로 사용)는 보조 인덱스는 데이터 항목을 찾기 위해 기본 인덱스의 간접 계층을 통과한다.

# Buffering, Immutability, and Ordering

버퍼링, 불변성, 순서 지정
--스터디 후에 정리하기--
