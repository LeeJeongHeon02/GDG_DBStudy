**고급 백엔드 스터디를 수강하게 된 계기?**

: 예전에 군대에서 정보처리기능사를 준비하면서 겉핥기로 SQL을 배웠다. 이때 DB라는것을 알게되었고, 백엔드 분야를 희망하게 되면서 DB에 대한 관심과 필요성이 느껴졌기 때문이다. 노베이스인 상태에서는 SQL이나 요즘 인기가 많다는 postgraSQL의 기본 문법부터 시작하는게 맞을수도 있지만, C언어를 배운 후 Python을 배우면 Pytheon이 쉽게 느껴지는 것과 같이 어려운 내용은 먼저 습득한 후, 쉬운 내용을 배우면 더 좋지 않을까? 그리고 이왕 배울거면 제대로 내부 구조나 DB가 동작하는 알고리즘과 같은 내용을 알고 DBMS를 사용하면 더 좋지 않을까? 라는 생각으로 수강하게 되었다. 기본 지식이 없는 입장에서 어렵게 느껴지겠지만, 스터디의 목표가 “어려운 내용을, 조금씩, 꾸준하게” 인 만큼 내가 시간을 할애하면 충분히 따라갈 수 있고, 더욱 발전할 수 있는 계기가 될 것 같다.

# OT

난이도는 높지만, 적은 분량

**스터디 목표** : “난이도 있는 토픽들을 조금씩 시간을 들여 탐구하자”

- 절대 몰아서 하지 말고, 하루에 조금씩 하는거로 하자.
    
    

**WIL작성** : 해당 주차 스터디 시작 “전”까지 제출

- 미리 예습하는건 필수. 그런데 혼자 해보니까 책 내용에 모르는것이 너무 많이서 예습이 힘들긴 하다. → 일단 책 내용을 정리한것을 WIL 에 작성한 후, 스터디로 내용을 이해한 후 느낀점을 다시 WIL에 쓰면 될듯하다.
    
    

**LLM사용**은 학습할때는 OK이지만, WIL작성할때는 복붙보다는 “나만의 표현”으로 직접 작성하기.

- 첫주차 스터디가 시작되기 전까지는 원서 번역한 내용 중 내가 이해가 된 내용들을 요점정리 식으로 썼는데, 그 내용을 바탕으로 내 생각을 써야겠다.
    
    

**롱텀 공부 어떻게 할까**

- 난 이 주제에 대해서 자신이 있는 편이므로 크게 걱정할 것은 없을거같다. 수능 재수라는 거의 1년의 롱텀 공부를 나름 성공적으로 마쳤으니…

## Part1 학습목표

- 스토리지 엔진이란 무엇이며, 데이터베이스 시스템에서 어떤 역할을 하는가? (난 스토리지 엔진도 무엇인지 모르는 상태이며 당연히 DB시스템에서도 어떤 역할을 하는지 모른다.)
- 우리에게 적합한 데이터베이스를 어떻게 선택할 수 있는가? (DB를 사용해본적이 없으니 당연히 이 내용도 모르는 내용이다)
- 스토리지 엔진 설계에는 어떤 트레이드오프가 존재하는가? (트레이드오프가 뭐지? → 데이터베이스에서 **트레이드오프(trade-off)**란 특정한 성능, 비용, 저장 공간, 응답 시간 등의 요소 중 하나를 향상시키기 위해 다른 요소를 희생해야 하는 상황)

**DB와 DBMS의 차이**

: DB는 구조화된 형태로 존재하는 데이터의 모음 그 자체를 뜻하지만, DBMS는 위의 DB에 대한 접근을 정의, 생성, 유지 및 제어할 수 있게 하는 소프트웨어 시스템을 뜻한다. 예를들어서 PostgreSQL은 DBMS 이고, 그 안에 저장된 데이터들은 DB이다. 둘은 엄밀하게 따지면 다르지만, 편의상 DBMS를 DB로 줄여서 말한다고 보면 될듯하다.

DBMS에는 요청을 받는 ‘트랜스포트 레이어’, 작업을 수행하는 ‘실행 엔진’, 그리고 지금부터 배워볼 ‘스토리지 엔진’ 이 있다. 

(+트랜스포트 레이어랑 실행 엔진에 대해 찾아본 내용)

- **트랜스포트 레이어**란 DBMS의 문지기 역할을 한다. 사용자가 데이터베이스에 어떤 작업을 요청하면, 이 레이어가 요청을 받아 적절한 방식으로 처리할 준비를 한다. 예를 들어, 웹사이트에서 로그인을 할 때, 데이터베이스에 "사용자가 입력한 아이디와 비밀번호가 맞는지 확인해줘!"라는 요청을 보낼 수 있다. 그리고 마치 우체국이 편지를 올바른 주소로 보내듯이, 적절한 경로를 통해 실행 엔진으로 전달한다.
- **실행 엔진**은 요청받은 작업을 **실제로 처리**하는 핵심 요소이다. 트랜스포트 레이어가 요청을 넘겨주면, 실행 엔진은 이를 분석하고 필요한 데이터베이스 연산을 수행한다. 예를 들어, 로그인 요청이 왔다면, 실행 엔진은 "사용자의 아이디와 비밀번호가 데이터베이스에 있는 값과 일치하는지 검사해야겠다!"라고 판단하고 해당 데이터를 찾아 비교한다.
    
    

### 스토리지 엔진 (1) - 개요

**스토리지 엔진의 역할**은 물류 센터로 생각해보면 입고, 출고, 창고 중에 창고라고 생각하면 된다. 즉, 데이터를 실제로 메모리/디스크에 저장하고, 검색하고, 관리하는 역할을 한다.

### 스토리지 엔진 (2) - 실제 사례

```sql
SELECT *
FROM users
WHERE age > 20;
// * = 전체에서
// users 테이블에서 (users 데이터 중에)
// age > 20인 데이터를 불러와라
```

**(쿼리** : 위와 같은 ****DB에 요청을 보내는 명령문)

위의 SQL쿼리를 실행한다면 내부에서 작동하는 구조는 아래와 같다.

- 트랜스포트 레이어를 통해 요청이 DBMS로 전달.
- 쿼리 프로세서가 이를 분석하여 실행 계획을 만든다.
- 실행 엔진이 이 계획을 수정한다. (계획을 수정한다는게 정확하게 뭔뜻인지 모르겠다)
- **스토리지 엔진**은 실제 users 테이블의 데이터를 디스크에서 찾아 메모리로 가져온다.

### 스토리지 엔진 (3) - DBMS와의 관계

**스토리지 엔진은?**

데이터를 생성하고, 읽고, 수정하고, 삭제하는 로우 레벨 조작.

**DBMS는?**

스토리지 엔진의 저수준 기능을 활용해서 추가적인 고수준 기능(스키마, 쿼리 언어, 인덱싱, 트랜잭션 등)을 제공함.

복잡한 쿼리 상황에서 DBMS의 고수준 기능이 필요해진다.(통계 데이터 활용, 인덱스 선택, 조인 순서 최적화, 실행 비용 추정) 

이 내용이 책에서의 **“데이터베이스가 복잡한 쿼리에 응답할 수 있는 반면, 스토리지 엔진은 (...) 간단한 데이터 조작 API를 제공합니다.”** 를 풀어서 정리한 내용이다.

### 스토리지 엔진 (4) - 바이트 덩어리만 보여

- Key-Value구조를 가진 저장소(파이썬의 Dict)를 생각해보자. DBMS의 스톨지 엔진 관점에서, 키-값 은 그냥 바이트 덩어리로 보인다.(컴퓨터에 데이터는 0과1로 저장되므로…)
    
    → 스토리지 엔진 관점에서는 어떤 데이터 타입이든 그냥 바이트 덩어리처럼 보인다.
    
    → 예를들어 사용자 ID를 키로, 이메일 주소를 값으로 가지는 구조를 생각해보자. 1001번 사용자의 ID는 int32 데이터 타입으로 저장된다면 00000000 / 00000000 / 00000011 / 11101001로 저장될것이다. 스토리지 엔진 입장에서는 얘가 정수로 1001이구나 라는 사실을 모르고 바이트 시퀀스만 저장한다. 이메일 주소도 동일하게 각 문자의 아스키코드값에 해당하는 바이트 시퀀스로 바뀌어서 저장된다. 그러면 스토리지 엔진은 이메일이구나 라는 사실을 모르고 바이트만 저장한다.
    

**위와 같은 행위를 “직렬화(Serialization)” 이라고 부른다.**

**직렬화**는 프로그램 내부에서 사용하는 객체나 데이터를 다른 프로그램에 전달하거나 저장 및 복구하기 위해 바이트 스트림 형태로 변환하는 과정을 말한다.

즉, 복잡한 객체의 상태를 메모리에 저장하거나 네트워크를 통해 전송하기 전에, 연속적인 데이터 형태로 변환하는것을 의미한다.

- 유연성을 위해 키-값은 정해진 형식 없는 임의의 바이트 시퀀스가 될 수 있습니다.
- 이들의 정렬 및 표현 의미론은 상위 레벨 서브시스템에 의해 정의됩니다.

지금까지 이해한 내용을 토대로 책에 나와있는 위의 말을 이해해보자.

**키-값은 정해진 형식 없는 임의의 바이트 시퀀스가 될 수 있습니다.**(데이터를 직렬화 시킬 수 있다)

**이들**(바이트 데이터들)

**의 정렬 및 표현 의미론은**(정렬 의미론 : 어떤 키의 크다/작다 를 어떻게 결정할지, 표현 의미론 : 바이트 덩어리를 원래 데이터 타입으로 어떻게 복원할지)

**상위 레벨 서브시스템**(스토리지 엔진의 상위 시스템은 DBMS)

**에 의해 정의**(DBMS가 바이트화 된 데이터들을 다시 원래의 데이터로 복호화해준다)

**됩니다.**

이 내용을들 이해하면 “**유연성을 위해”** 라는 말을 이렇게 유추해 볼 수 있다.

- 스토리지 엔진을 유연하게 교체할 수 있게 하기 위해서…(정확하게 모르겠으니 대충 호환성을 좋게 하기 위해서라고 이해해보자.)

### 스토리지 엔진 (5) - 유연한 교체

- 많은 스토리지 엔진은 특정 DBMS에 맞춰서 개발된 것이 아니라, DBMS와 독립적으로 개발되었다.
- 유연한 교체가 가능한 스토리지 엔진을 ‘**플러거블 스토리지 엔진**' 이라고 부른다.
- 이렇게 미리 만들어진 스토리지 엔진을 사용하여 DBMS를 세팅(=부트스트래핑) 할 수 있다.
    
    → 그러면 개발자는 다른 부분(쿼리 최적화, 트랜잭션 등)에 집중 가능해서 좋다.
    
    **MySQL의 스토리지 엔진**
    
    - InnoDB → 트랜잭션, 외래 키 지원 O, ACID 준수
    - MyISAM → 빠른 읽기 가능하지만, 트랜잭션 지원 안함
    - RocksDB → LSM 트리 기반으로 쓰기가 많은 환경에 적합
    
    **MongoDB의 스토리지 엔진**
    
    - WiredTiger → 쓰기 작업에 문서 수준 락을 걸 수 있음
    - In-Memory → 메모리에 데이터를 저장하여 빠른 엑세스 가능

(그냥 읽고, 그렇구나 하고 넘어가기..)

**이런 것들이 가능한 이유 : 데이터들이 직렬화 되기 때문.**

## DB의 비교

### 왜?

- DBMS / 스토리지 엔진 선택은 매우 중요하다. 성능, 일관성 문제, 운영 상 어려움 등이 있을 때 조기에 파악이 필요하기 때문이다.
- 현업에서는 마이그레이션(데이터를 옮기는 것)이 어렵고, 애플리케이션 코드에도 영향을 주기 때문이다.
- 데이터베이스를 비교할때는 각 DBMS가 내부적으로 어떻게 작동하는지 간단하게라도 알아야 한다.
- 이렇게 비교하면 안된다. (DBMS의 구성 요소들만 보거나, DB비교 웹사이트에서 인기 순위를 보고 고르거나, 구현 언어를 보고 고르거나…)

### 어떻게 비교해야하나?

- 우리 서비스의 워크로드를 기반으로 비교하거나
- 다양한 DBMS에서 테스트를 돌려보고 성능 지표 기반으로 결정한다.
- 테스트를 할 때는 최대한 프로덕션 환경과 가깝게 해야한다. 실제 문제는 시간이 지나고, 용량이 커지면 발생한다.

데이터베이스를 비교할 때 성능만 중요한것이 아니다.

- 운영 편의성
- 디버깅 방법
- 커뮤니티 규모(정보를 얻을 수 있는 규모?)
- 성능 테스트 도구 등

 의외로 성능은 가장 중요하지 않은 경우가 많다. 예를들어서 성능이 좋은데 데이터도 빨리 유실되는 DB(+ DB에서 임시 데이터를 저장할 때, 일정 시간이 지나면 자동으로 삭제되도록 설정할 수 있다. 이 데이터들을 뜻하는거겠지…?), 느린 대신 데이터도 느리게 유실되는 DB중에 선택을 하라고 하면 당연히 후자를 선택해야한다.

+데브시스터즈 “CTO가 커리어를 걸고 비트 레벨까지 내려가서 DB를 해킹했던 이야기” 를 읽어보았다. 현업에서 이런 문제 상황에 대해서 어떻게 해결하는지 스토리가 흥미로웠다. 모르는 단어(내용들)은 많았지만, 대충 문제가 생겼는데 기술 지원도 불가능한 상황에서 데이터의 스토리지 엔진 부분까지 내려가서 문제가 생긴 부분을 찾고, 복구하고, 검증하고 다시 서비스를 배포한 내용인듯 하다. 이 글을 읽으면서 가장 먼저 든 생각은 “재미있겠다”이다. 당사자 입장에서는 머리아프고 힘든 상황이겠지만, 저런 문제상황이 생긴다면 내 삶에서 퀘스트가 생긴 듯한 재미를 느낄거같다. 나도 열심히 공부해서 저런 문제 상황을 잘 해결할 수 있는 개발자가 되는 것을 목표로 해야겠다…

- 위의 상황처럼 DB의 내부 동작 원리를 알고 있어야 문제 상황에서 빠르고, 정확하고, 좋은 성능으로 해결할 수 있다.

### 트레이드오프 이해하기

- DB를 결정하기 전에 고려해야 할 사항들은 위처럼 많다.
- 선택과 집중을 요구하는 “트레이드오프”
- 각 상황에 맞게 개발된 스토리지 엔진들이 존재 → 각자의 상황에 맞는 스토리지 엔진을 고르면 된다.

# Ch 1. Introduction And
Overview (1)

## 학습목표

- DBMS의 목적에 따른 분류
- DBMS의 아키텍쳐
- 메모리 기반 DBMS와 디스크 기반 DBMS

 책에서 말하기에는 DBMS는 임시 핫 데이터, 장기 콜드 스토리지, 복잡한 분석 쿼리, 키-값 액세스, 시계열 데이터 저장, 대용량 BLOB 저장 등 의 다양한 목적을 수행한다고 한다. 솔직히 뭔소리인지 잘 모르겠고, DBMS는 데이터를 쉽게 관리하고, 찾을 수 있게 해주는 편리한 도구라고 생각한다. 위의 내용들은 차차 알아가보자.

### DBMS의 분류

저장 매체의 관점에서는 Memory-based DBMS와 Disk-based DBMS로 나뉜다고 보면 된다. 레이아웃 관점에서는 Column-oriented DBMS, Row-oriented DBMS로 나뉜다고 보면 된다. 다른 기타 분류 방법(OLTP, OLAP, HTAP)도 있지만 책에서 말하기에 여기서 논의하는 개념은 대부분의 저장소 유형에 광범위하게 적용되므로 완전한 분류는 필요하지 않다고 한다. 책에서는 저장 및 인덱싱 구조에 초점을 맞추므로 데이터 및 인덱스 파일 간의 관계와 효율적인 저장 구조 개발에 사용되는 세 가지 기술(버퍼링, 불변성, 순서 지정)에 대해 논의한다고 한다.

### DBMS Architecture - client/server model

DBMS는 클라이언트/서버 모델을 사용하며, 데이터베이스 시스템 인스턴스(노드)가 서버 역할을 하고 애플리케이션 인스턴스가 클라이언트 역할을 한다. → 클라이언트/서버 관계는 백엔드 정규 스터디 시간에 들었던 내용…

![image](https://github.com/user-attachments/assets/ee654c16-2d6e-48ad-b32c-4e83672abc48)


(위 그림처럼 구조가 명확하다면 이해하기 쉽겠지만, 실제로는 여러 요소들이 결합되어서 동작한다.)

## DBMS Architecture

- **전송 하위 시스템**은 클라이언트 요청(쿼리 형태)을 수신하고 다른 노드와의 통신을 담당한다. 그리고 쿼리를 쿼리 프로세스에 전달한다.
- **쿼리 프로세서**는 쿼리를 구문 분석하고 해석하며 유효성을 검사한다. 액세스 제어 검사는 쿼리가 해석된 후에 수행된다. 액세스 제어 검사는 사용자 권한에 따라서 쿼리를 허용하거나 불허해야 하기 때문.(public, private 같은 접근 제어자를 확인하는 과정이라고 이해하자.)
- **쿼리 최적화기**는 파싱된 쿼리를 받아서 불가능하거나 중복된 부분을 제거하고, 내부 통계 및 데이터베이스 배치를 기반으로 가장 효율적인 실행 방법을 찾는다. 쿼리 최적화기는 쿼리 해결에 필요한 관계형 연산과 인덱스 순서 지정, 카디널리티 추정, 액세스 방법 선택과 같은 최적화를 모두 처리한다.
    - Index cardinality란? 인덱스 컬럼에 존재하는 값들의 다양한 정도. 학교 학생들이 저장된 테이블이 있다고 치면, 학번은 학생마다 모두 다르므로 Key값 취급이 가능하면서 index Cardinality가 높다. 반면에 성별은 남/녀 둘중 하나의 값을 가지므로(요즘 시대에는 아닐수도?) index Cardinality가 매우 낮다. → 인덱스의 목적을 고려하면  index Cardinality가 높게 설정해야한다.
- **실행 엔진**은 로컬 및 원격 작업 실행 결과를 수집한다. 원격 실행에는 다른 노드와의 데이터 읽기/쓰기 및 복제가 포함될 수 있고, 로컬 실행은 Storage Engine에 Local Query를 넘겨서 실행하는 것이다.
- 트랜잭션이란?
    
    데이터베이스에서 실행될 작업들의 덩어리.
    
    ACID 성질을 가진다.
    
    Atomicity
    Consistency
    Isolation
    Durability
    
- **스토리지 엔진**은 ****로컬 쿼리(클라이언트 또는 다른 노드에서 직접 오는 쿼리)를 실행한다.
    - **트랜잭션 관리자** : 트랜잭션을 스케줄링하고 논리적으로 **일관성(ACID 중 Consistency)** 없는 상태로 데이터베이스를 남기지 않도록 보장한다.
    - **잠금 관리자** : 실행 중인 트랜잭션을 위해 데이터베이스 객체에 대한 잠금을 관리하여 동시 작업이 **물리적 데이터 무결성(ACID 중 Isolation)** 위반하지 않도록 한다.
    - **액세스 방법(스토리지 구조)**: 디스크의 데이터 액세스 및 구성을 관리한다. 힙 파일 및 B-트리, LSM 트리와 같은 스토리지 구조가 해당된다.
    - **버퍼 관리자** : disk에서 page단위로 읽어온 데이터 페이지를 메모리에 캐싱한다.
    - **복구 관리자** : 작업 로그를 유지 관리하고 실패 시 시스템 상태를 복원한다.

## Memory vs Disk-based DBMS

 메모리 베이스는 데이터를 메모리에 저장하고, 복구와 로깅 목적으로 disk를 사용한다.

 디스크 베이스는 대부분의 데이터를 디스크에 저장하고 메모리를 캐싱하거나, 임시로 중간 연산 결과를 저장할 때 사용한다.

### Memory-based가 가지는 이점

 메모리 베이스 DBMS는 데이터에 접근하는 시간은 disk에 접근하는 시간보다 훨씬 빠르지만, 디스크는 page단위로 읽는 반면에 메모리는 워드 단위로 읽는다. (디스크와 메모리의 성능 차이에 대해서는 알고 있었지만, 저장된 내용을 읽는 단위가 다른점은 처음알았다. 디스크는 Page단위로 (보통 4KB) 데이터를 읽고, 메모리는 바이트 또는 워드(4 ~ 8 byte) 단위로 데이터를 읽는다.)

### Memory가 이렇게 좋은데 Disk-based도 쓰는 이유?

 속도 측면에서는 메모리가 압도적이지만 Disk도 쓰는 이유는 컴퓨터에서 하드디스크(HDD)와 메모리(RAM)의 차이랑 비슷하다. 메모리는 비싸고, 저장 공간의 크기도 적은 편이다. 그리고 전원 공급이 되지 않으면 데이터가 날라간다. → 그래서 disk가 데이터를 관리하기 쉽고 비용 측면에서도 유리하다(평소에 교수님들이 자주 하는 이야기… 특히 쁘띠지헌교수님이 “빳데리 날리지 말으셔” 라고도 하시고 이준용교수님도 “공학도들은 비용 효율적인게 중요하다” 라고 하셨던거같다).

### Memory 기반의 Durability(지속성)를 위한 것들

- disk 백업을 지원하여 data loss를 방지한다.
- **쓰기-전 로그(Write-Ahead Log)** : 작업이 완료된 것으로 간주되기 전에 해당 결과가 순차 로그 파일에 기록되어야 한다.
- **백업 복사본(Backup Copy)** : 충돌이 생겼을 때, 전체 로그 콘텐츠를 재생하지 않도록 백업 복사본은 유지한다. 백업 복사본은 정렬된 디스크 기반 구조로 유지된다.
- **체크포인팅(Checkpointing)** : 디스크에 저장된 스냅샷을 가져온 후 log file에 순차적으로 기록해둔 변경사항들을 반영해서 새로운 백업 복사본을 만드는 과정이다. → Disk내용을 최신화하여 복구 시간을 줄일 수 있다.

---

*아래는 스터디 시작 전에 책 번역한거 복붙한내용들*

---

## Part 1: 스토리지 엔진 (Storage Engines)

- **스토리지 엔진의 역할** : 스토리지 엔진(또는 데이터베이스 엔진)은 DBMS의 소프트웨어 구성 요소로, 메모리와 디스크에 데이터를 저장, 검색, 관리하는 역할을 합니다
- DBMS는 스토리지 엔진 위에 구축된 애플리케이션으로 볼 수 있으며, 스키마, 쿼리 언어, 인덱싱, 트랜잭션 등 유용한 기능을 제공합니다.

### 데이터베이스 비교 및 테스트

- 성능보다 운영 안정성이 더 중요할 수 있습니다 (데이터를 빠르게 잃는 것보다 느리게 저장하는 것이 낫습니다).

**비교 전 고려 사항**

1. 데이터베이스를 비교하기 전에 사용 사례를 자세히 이해하고 현재 및 예상 변수(스키마 및 레코드 크기, 클라이언트 수, 쿼리 유형 및 액세스 패턴, 읽기/쓰기 쿼리 속도, 예상 변경 사항)를 정의하는 것이 중요합니다. 
2. 이를 통해 데이터베이스가 요구 사항을 충족하는지, 예상 데이터 양을 처리할 수 있는지, 필요한 노드 수, 클러스터 확장 방법, 유지 관리 프로세스 등을 파악할 수 있습니다. 

### 데이터베이스 벤치마크

- **YCSB (Yahoo! Cloud Serving Benchmark)**: 벤치마킹, 성능 평가 및 비교에 사용되는 인기 있는 도구입니다.
- **TPC-C 벤치마크**: Transaction Processing Performance Council(TPC)는 데이터베이스 공급업체가 제품 성능을 비교하고 광고하는 데 사용하는 벤치마크 세트를 가지고 있습니다. TPC-C는 일반적인 애플리케이션 워크로드를 시뮬레이션하는 읽기 전용 및 업데이트 트랜잭션이 혼합된 온라인 트랜잭션 처리(OLTP) 벤치마크입니다. 이 벤치마크는 동시 실행되는 트랜잭션의 성능과 정확성에 중점을 둡니다.

## 트레이드오프의 이해

데이터베이스를 사용할 때는 다양한 조건에서 어떻게 작동하는지 볼 수 있지만, 데이터베이스를 개발할 때는 이러한 동작에 직접적인 영향을 미치는 선택을 해야 합니다. 물리적 데이터 레이아웃 설계, 포인터 구성, 직렬화 형식 결정, 가비지 컬렉션 방식 이해, 동시 환경에서의 작동 방식 파악, 데이터 손실 방지 등 고려해야 할 세부 사항과 엣지 케이스가 많습니다.

## 1장 : 소개 및 개요

**데이터베이스 분류** : DBMS는 다양한 목적을 수행합니다 (임시 핫 데이터, 장기 콜드 스토리지, 복잡한 분석 쿼리, 키-값 액세스, 시계열 데이터 저장, 대용량 BLOB 저장 등). 이 장에서는 **차이점을 이해**하고 추가 논의 범위를 파악하는 데 도움이 되는 **간략한 분류 및 개요**부터 시작합니다.

## DBMS 아키텍처

- **일반적인 아키텍처** : DBMS 설계에 대한 공통적인 청사진은 없으며, 모든 데이터베이스는 약간 다르게 구축되고 구성 요소 경계는 정의하기 어려울 수 있습니다. 문서상 경계가 존재하더라도 코드에서는 성능 최적화, 엣지 케이스 처리 또는 아키텍처 결정으로 인해 독립적으로 보이는 구성 요소가 결합될 수 있습니다.
- **클라이언트/서버 모델** : DBMS는 클라이언트/서버 모델을 사용하며, 데이터베이스 시스템 인스턴스(노드)가 서버 역할을 하고 애플리케이션 인스턴스가 클라이언트 역할을 합니다.

![image.png](attachment:89266e1e-dc28-4fbe-8183-72a6d5cfebf3:image.png)

## **요청 처리 흐름**

1. **전송 하위 시스템(Transport Subsystem)** : 클라이언트 요청(쿼리 형태)을 수신하고 다른 노드와의 통신을 담당합니다.
2. **쿼리 프로세서(Query Processor)**: 쿼리를 구문 분석, 해석 및 유효성 검사합니다. 액세스 제어 검사도 수행합니다.
3. **쿼리 최적화기(Query Optimizer)**: 쿼리의 불가능하고 중복된 부분을 제거하고 내부 통계 및 데이터 배치를 기반으로 가장 효율적인 실행 방법을 찾습니다. 관계형 연산 및 최적화(인덱스 순서 지정, 카디널리티 추정 등)를 처리합니다.
4. **실행 계획(Execution Plan)**: 쿼리를 완료하기 위해 수행해야 하는 작업 시퀀스입니다. 최적화기는 사용 가능한 최상의 계획을 선택합니다.
5. **실행 엔진(Execution Engine)**: 로컬 및 원격 작업 실행 결과를 수집합니다. 원격 실행에는 다른 노드와의 데이터 읽기/쓰기 및 복제가 포함될 수 있습니다.
6. **스토리지 엔진(Storage Engine)**: 로컬 쿼리(클라이언트 또는 다른 노드에서 직접 오는 쿼리)를 실행합니다. 여러 구성 요소(트랜잭션 관리자, 잠금 관리자, 액세스 방법, 버퍼 관리자, 복구 관리자)를 포함합니다
