## 페이지 헤더
- 페이지 헤더는 데이터 페이지의 개요(명찰)이다.
- DB는 데이터를 일정한 크기(4~16KB)의 페이지 단위로 묶어서 관리하는데, 각 페이지의 맨 앞부분에 해당 페이지에 대한 모든 관리 정보를 기록한다. 이것이 페이지 헤더이다.
- DBMS가 이 페이지 헤더의 정보만 보고 페이지의 상태나 구조를 파악할 수 있다.
페이지 헤더의 주된 역할은 책에서 설명한 대로 **탐색, 유지보수, 최적화**이다.
1. **탐색 (Navigation):** 페이지 안에 데이터가 몇 개 있고, 어디에 저장되어 있는지 알려줍니다. 덕분에 페이지 내에서 특정 데이터를 빠르게 찾을 수 있다.
2. **유지보수 (Maintenance):** 페이지에 남은 공간이 얼마나 되는지, 데이터가 얼마나 조각나 있는지 등의 정보를 담아 공간을 재사용하거나 조각 모음을 할 때 사용된다.
3. **최적화 (Optimization):** 이 페이지가 B-Tree의 리프 노드인지, 내부 노드인지 같은 구조적인 정보를 담아, 시스템이 페이지의 종류에 맞는 최적의 작업을 수행하게 해준다.
## 매직 넘버
매직 넘버의 핵심 역할은 **파일 식별(FIle identification)**, **유효성 및 온전성 검사(Validation & Sanity Check** 이다.
- 파일 식별 : 매직 넘버를 확인함으로서 자신의 데이터베이스가 만든 B-Tree 페이지임을 바로 확인가능하다.
	- 다른 프로그램이 만든 파일이거나, 데이터가 손상된 상태라면 매직 넘버가 다를 것이므로 오류를 빠르게 감지가능하다.
- 유효성 및 온전성 검사 : 매직 넘버가 예상하는 값과 다르면 데이터가 손상되었다는 사실을 바로 확인할 수 있다.

## 형제 링크
간단히 말해서 B-Tree에서 수직(부모자식관계)으로 연결해주는 포인터가 아니라 좌우(형제관계)로 연결해주는 포인터이다.
- 형제 링크가 없을 경우, 넓은 범위의 데이터를 스캔할 때, 부모 노드로 올라갔다가, 자식 노드로 내려갔다가를 반복해야한다.
- 형제 링크가 있으면, 부모 노드가 아닌 형제 노드로 바로 이동이 가능해서 **범위 스캔 성능의 상향**이 가능하다.
- 단점은 구조를 변경할 때(Merge, Split) 추가 작업(포인터 재할당)이 필요하다.

## 가장 오른쪽 포인터(Rightmost Pointers)
- 키보다 포인터가 항상 하나 더 많다.(N개의 키는 N+1개의 포인터 경로를 만들어서...)
- 실제로 데이터 페이지를 저장할 때는 키 & 벨류 쌍을 저장하는 경우가 많다.
- 이 경우, N + 1번째 포인터가 혼자 남는다. 이 포인터를 페이지 헤더에 따로 저장하는것이다.
	- (SQLite가 이 방식을 사용한다)

## 노드 상위 키
'가장 오른쪽 포인터' 방식의 단점을 보완하고 구조를 더 단순하게 만든 방식이다.
- 짝 없는 마지막 포인터에게 짝(=키)을 만들어주는 방식이다. 
- 모든 포인터를 동일한 구조의 (키, 포인터)로 관리할 수 있어서, 가장 오른쪽 포인터와 같은 예외 처리가 필요없다.
- **PostgreSQL에서의 Blink-트리와의 연관성:** 책에서 언급했듯이, PostgreSQL에서 사용하는 **Blink-트리**는 바로 이 '상위 키'를 활용하여 동시성을 높인 B-트리의 고급 변형입니다. 다른 스레드가 노드를 분할하고 있을 때도, 검색 스레드는 이 상위 키 정보를 보고 "아, 이 노드의 경계는 여기까지구나. 내가 찾는 값은 이 노드를 벗어났으니 옆에 있는 형제 노드로 가봐야겠다"라고 판단하여 멈추지 않고 탐색을 계속할 수 있습니다.

## 오버플로 페이지
데이터는 고정된 크기의 페이지에 담아서 관리된다는것은 알고있다. 그러면 이 고정된 크기의 페이지보다 큰 데이터를 저장해야 할 때 어떻게 해야 할까? 에 대한 답변이 오버플로 페이지이다.
- 한줄요약하면, 데이터의 일부는 주 페이지에 두고, 넘치는 데이터는 오버플로 페이지에 두는 것이다.
- 링크드리스트처럼 데이터가 오버플로우된다면, 새로운 오버플로 페이지를 만들고 새로운 오버플로 페이지의 주소를 기존의 페이지에 기록해서 체인처럼 계속 연결하는 방식이다.

## Binary Search
알고리즘 공부할때 공부했던 그 Binary Search 맞다.
- 하나의 B-Tree 노드에는 여러 개의 키가 저장될 수 있다. 이때, 이 노드 안에서 BS를 통해서 키값을 찾는다.
실제 B-Tree 구현에는 '슬롯 페이지'구조를 활용한 간접 포인터를 통한 바이너리 서치가 활용된다.
- 실제 데이터들은 페이지의 한쪽 끝에 순서 없이 저장된다.
- 데이터들의 위치를 가리키는 포인터들을 반대쪽에 키 순서대로 정렬해서 보관한다.
- 이 정렬된 포인터값을 통해 BS를 하고, 이를 통해 원하는 키 값을 찾은 후, 그 데이터가 저장되어있는 곳으로 이동해서 데이터를 읽는다.

## 분할과 병합 전파하기
B-Tree는 자료가 추가되거나 삭제될 때, 각 노드가 너무 꽉 차거나, 너무 데이터가 없으면 병합과 분할을 한다.
만약 리프 노드가 둘로 쪼개졌다고 치면, 이 두 노드를 구분할 구분 키가 필요하다. 이 구분 키는 부모 노드에 등록되어야한다.
반대로, 두 리프 노드가 하나로 합쳐지면 필요 없어진 포인터와 구분 키를 제거해야한다.
이 '리프 노드 입장에서 자신의 부모가 누구인지 어떻게 알 수 있을까?'의 해결책중 하나가 '부모 노드 포인터' 이다.
### 부모 노드 포인터
: 각 노드에 '나의 부모는 ~ 입니다' 라고, 부모 노드의 주소를 직접 저장하고 있는 방식이다.
1. 리프 노드에서 분할이 발생
2. 분할된 노드는 자신의 부모 노드 포인터를 읽는다.
3. 이 포인터를 이용해 부모 노드에 접근해서, 승격시킬 키와 새로 생긴 노드를 기리키는 포인터를 전달한다.
- 자식 노드가 부모를 찾아야 할 떄, 매우 빠르게 찾을 수 있다.
- 하지만, 부모 노드 자체가 분할되거나 병합될 때, 유지보수 비용이 발생한다(모든 자식 노드를 찾아가서 부모 노드 포인터를 새로 할당해줘야한다.). 

### 경로 추적(Breadcrumbs)
: 간단하게, 데이터를 찾으러 가는 길에 내가 지나온 경로를 임시로 기억해두자. 라는 아이디어다.
동작 과정
1. B-Tree의 루트 노드부터 탐색을 시작한다.
2. 루트 노드에서 다음 자식 노드로 내려간다. 그리고, '루트 노드에서 이 노드로 내려왔다'라는 정보를 **스택**에 저장한다.
3. 자식 노드로 내려갈떄마다 이 정보를 저장해서 (루트 정보 - 중간 노드 정보 - 부모 노드 정보) 순서대로 스택이 쌓인다.
4. 리프 노드에 도착했는데 분할이 필요하다? 그러면 이 사실을 부모에게 알려야한다.
5. 이때 스택에서 pop해서 직전 부모 정보를 pop한다.
6. 혹시 부모 노드에서도 분할이 필요하면, 다시 pop해서 부모 노드의 부모 노드에게 알리면 된다.
7. 분할/병합 작업이 다 끝나면, 이 스택은 필요없어졌으므로 삭제한다.

부모 노드 포인터와 경로 추적의 장단점을 비교해보면
부모 노드 포인터는 항상 자기가 부모 노드의 주소를 가지고있어서 부모 노드로의 접근이 빠르지만, 부모 노드가 분할/병합할 경우 모든 자식 노드에 대해서 포인터 재할당이 필요하다. 경로 추적 방식은 스택을 이용해서 부모가 분할/병합되어도 자식 노드를 수정할 필요가 없다. 하지만 정보를 스택에 저장하므로 아주 미미하게 메모리/연산 오버헤드가 발생한다.
